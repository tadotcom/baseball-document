# 第13章 エラーハンドリング設計

## 13.1 エラーハンドリング方針

### サーバー側 (Laravel)

- 全ての例外を `app/Exceptions/Handler.php` でキャッチし、統一されたJSON形式のエラーレスポンスを返却する
- エラーコードとメッセージは「エラーメッセージ定義書.csv」に基づく
- 予期しないエラー（500系）は詳細をログに記録し、クライアントには一般的なメッセージのみ返す（情報漏洩防止）

### クライアント側 (Flutter)

- APIレスポンスのステータスコードとエラーコードに基づいて、適切なエラー表示を行う
- 表示方法は固定ルールに従う:
  - **トースト/スナックバー:** 認証エラー (401)、一般的なエラー
  - **ダイアログ:** サーバーエラー (500)、致命的なエラー
  - **インラインエラー:** バリデーションエラー (422)

## 13.2 Laravel Exception Handler 実装

**ファイル:** `app/Exceptions/Handler.php`

```php
<?php

namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Validation\ValidationException;
use Illuminate\Auth\AuthenticationException;
use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Throwable;

class Handler extends ExceptionHandler
{
    /**
     * A list of exception types with their corresponding custom log levels.
     *
     * @var array<class-string<\Throwable>, \Psr\Log\LogLevel::*>
     */
    protected $levels = [
        //
    ];

    /**
     * A list of the exception types that are not reported.
     *
     * @var array<int, class-string<\Throwable>>
     */
    protected $dontReport = [
        //
    ];

    /**
     * A list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * Register the exception handling callbacks for the application.
     */
    public function register(): void
    {
        $this->reportable(function (Throwable $e) {
            //
        });
    }

    /**
     * Render an exception into an HTTP response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Throwable  $e
     * @return \Symfony\Component\HttpFoundation\Response
     *
     * @throws \Throwable
     */
    public function render($request, Throwable $e)
    {
        // API リクエストの場合、JSON形式でエラーレスポンスを返す
        if ($request->expectsJson()) {
            return $this->handleApiException($request, $e);
        }

        return parent::render($request, $e);
    }

    /**
     * API例外を統一されたJSON形式で返却
     */
    protected function handleApiException($request, Throwable $e)
    {
        $statusCode = 500;
        $errorCode = 'E-500-03';
        $message = 'サーバーエラーが発生しました';
        $details = null;

        // バリデーションエラー (422)
        if ($e instanceof ValidationException) {
            $statusCode = 422;
            $errorCode = 'E-422-01'; // 代表的なエラーコード
            $message = 'バリデーションエラーが発生しました';
            $details = $this->formatValidationErrors($e->errors());
        }
        // 認証エラー (401)
        elseif ($e instanceof AuthenticationException) {
            $statusCode = 401;
            $errorCode = 'E-401-01';
            $message = '認証に失敗しました';
        }
        // 権限エラー (403)
        elseif ($e instanceof AuthorizationException) {
            $statusCode = 403;
            $errorCode = 'E-403-01';
            $message = '管理者権限が必要です';
        }
        // リソース未検出 (404)
        elseif ($e instanceof ModelNotFoundException || $e instanceof NotFoundHttpException) {
            $statusCode = 404;
            $errorCode = 'E-404-01';
            $message = 'リソースが見つかりません';
        }
        // カスタム例外
        elseif (method_exists($e, 'getStatusCode')) {
            $statusCode = $e->getStatusCode();
            $errorCode = $e->getErrorCode() ?? 'E-500-03';
            $message = $e->getMessage();
        }

        // エラーログ記録 (500系のみ)
        if ($statusCode >= 500) {
            \Log::error('サーバーエラー', [
                'error_message' => $e->getMessage(),
                'stack_trace' => $e->getTraceAsString(),
                'endpoint' => $request->path(),
                'user_id' => $request->user() ? $request->user()->id : null,
            ]);
        }

        // 統一されたJSON形式でレスポンスを返却
        return response()->json([
            'error' => [
                'code' => $errorCode,
                'message' => $message,
                'details' => $details,
            ],
            'meta' => [
                'timestamp' => now()->toIso8601String(),
            ],
        ], $statusCode);
    }

    /**
     * バリデーションエラーをdetails配列に整形
     */
    protected function formatValidationErrors(array $errors)
    {
        $details = [];
        foreach ($errors as $field => $messages) {
            $details[] = [
                'field' => $field,
                'message' => implode(', ', $messages),
            ];
        }
        return $details;
    }
}
```

## 13.3 カスタム例外クラス

特定のビジネスロジックエラーに対して、カスタム例外クラスを定義する。

### 例: CheckinException

**ファイル:** `app/Exceptions/CheckinException.php`

```php
<?php

namespace App\Exceptions;

use Exception;

class CheckinException extends Exception
{
    protected $errorCode;
    protected $statusCode;

    public function __construct(string $errorCode, string $message, int $statusCode = 400)
    {
        parent::__construct($message);
        $this->errorCode = $errorCode;
        $this->statusCode = $statusCode;
    }

    public function getErrorCode(): string
    {
        return $this->errorCode;
    }

    public function getStatusCode(): int
    {
        return $this->statusCode;
    }
}
```

### 使用例

```php
// チェックイン可能時間外
throw new CheckinException('E-400-09', 'チェックイン可能時間外です', 400);

// 試合会場から離れている
throw new CheckinException('E-400-10', '試合会場から離れているためチェックインできません', 400);
```

## 13.4 Flutter エラーハンドリング実装

### API Client での統一的なエラーハンドリング

**ファイル:** `lib/core/api/api_client.dart`

```dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class ApiClient {
  Future<Map<String, dynamic>> post(
    String endpoint,
    Map<String, dynamic> body,
    {String? token}
  ) async {
    try {
      final response = await http.post(
        Uri.parse(endpoint),
        headers: {
          'Content-Type': 'application/json',
          if (token != null) 'Authorization': 'Bearer $token',
        },
        body: jsonEncode(body),
      );

      if (response.statusCode == 200 || response.statusCode == 201) {
        return jsonDecode(response.body);
      } else {
        // エラーレスポンスをパースして例外をスロー
        final errorData = jsonDecode(response.body);
        throw ApiException(
          statusCode: response.statusCode,
          errorCode: errorData['error']['code'],
          message: errorData['error']['message'],
          details: errorData['error']['details'],
        );
      }
    } catch (e) {
      // ネットワークエラーなど
      throw ApiException(
        statusCode: 0,
        errorCode: 'E-NETWORK',
        message: 'ネットワークエラーが発生しました',
      );
    }
  }
}
```

### ApiException クラス

**ファイル:** `lib/core/exceptions/api_exception.dart`

```dart
class ApiException implements Exception {
  final int statusCode;
  final String errorCode;
  final String message;
  final List<dynamic>? details;

  ApiException({
    required this.statusCode,
    required this.errorCode,
    required this.message,
    this.details,
  });

  @override
  String toString() {
    return 'ApiException: $errorCode - $message';
  }
}
```

### エラー表示の実装

**トースト/スナックバー表示:**

```dart
void showErrorSnackBar(BuildContext context, String message) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: Colors.red,
      duration: Duration(seconds: 3),
    ),
  );
}
```

**ダイアログ表示:**

```dart
void showErrorDialog(BuildContext context, String title, String message) {
  showDialog(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text('閉じる'),
        ),
      ],
    ),
  );
}
```

**Provider でのエラーハンドリング例:**

```dart
class LoginProvider extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> login(String email, String password) async {
    state = const AsyncLoading();

    try {
      final result = await apiClient.post('/api/v1/auth/login', {
        'email': email,
        'password': password,
      });

      // トークンを保存
      await tokenStorage.save(result['data']['token']);

      state = const AsyncData(null);
      
      // 成功時の画面遷移
      // ...
      
    } on ApiException catch (e) {
      state = AsyncError(e, StackTrace.current);

      // エラーコードに応じた表示
      if (e.statusCode == 401) {
        // トーストで表示
        showErrorSnackBar(context, e.message);
      } else if (e.statusCode == 422) {
        // インラインエラーで表示
        // details を使ってフィールドごとにエラー表示
      } else if (e.statusCode >= 500) {
        // ダイアログで表示
        showErrorDialog(context, 'エラー', e.message);
      }
    }
  }
}
```

## 13.5 エラー表示ルール (固定ルール)

| HTTPステータス | エラーコード | 表示方法 | 表示内容 |
|---|---|---|---|
| 401 | E-401-01, E-401-02 | トースト/スナックバー | エラーメッセージ |
| 403 | E-403-01 | トースト/スナックバー | エラーメッセージ |
| 404 | E-404-01, E-404-02 | トースト/スナックバー | エラーメッセージ |
| 409 | E-409-01~04 | トースト/スナックバー | エラーメッセージ |
| 422 | E-422-01~08 | インラインエラー | フィールドごとのエラーメッセージ |
| 500 | E-500-01~03 | ダイアログ | エラーメッセージ |
| ネットワークエラー | E-NETWORK | ダイアログ | 「ネットワークエラーが発生しました」 |

---

# 第14章 テスト設計

## 14.1 テスト方針

### テストレベル

本システムでは以下のテストレベルを実施する:

1. **単体テスト (Unit Test):** 個別の関数・メソッドの動作を検証
2. **統合テスト (Integration Test):** 複数のコンポーネント（Controller + Service + Repository）の連携を検証
3. **E2Eテスト (End-to-End Test):** ユーザー視点での画面操作フロー全体を検証

### テスト対象

- **Laravel (サーバー側):**
  - 単体テスト: Service層、Utilityクラス
  - 統合テスト: API (Controller + FormRequest + Service)
  
- **Flutter (クライアント側):**
  - 単体テスト: Provider、Utilityクラス
  - Widget テスト: 個別のWidgetの表示・操作
  - 統合テスト: 画面遷移フロー

### カバレッジ目標

- **Laravel:** 80%以上（重要なビジネスロジックは100%）
- **Flutter:** 70%以上

## 14.2 Laravel テスト設計

### テストフレームワーク

**PHPUnit** (Laravel標準)

### テストディレクトリ構造

```
tests/
├── Feature/          # 統合テスト（APIテスト）
│   ├── Auth/
│   │   ├── LoginTest.php
│   │   └── RegisterTest.php
│   ├── Game/
│   │   ├── GameListTest.php
│   │   └── CheckinTest.php
│   └── Admin/
│       └── UserManagementTest.php
├── Unit/             # 単体テスト
│   ├── Services/
│   │   ├── AuthServiceTest.php
│   │   └── CheckinServiceTest.php
│   └── Utils/
│       └── DistanceCalculatorTest.php
└── TestCase.php      # ベーステストケース
```

### APIテスト例 (統合テスト)

**ファイル:** `tests/Feature/Auth/LoginTest.php`

```php
<?php

namespace Tests\Feature\Auth;

use Tests\TestCase;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;

class LoginTest extends TestCase
{
    use RefreshDatabase;

    /** @test */
    public function ログインが成功する()
    {
        // Arrange: テストデータ作成
        $user = User::factory()->create([
            'email' => 'test@example.com',
            'password' => bcrypt('password123'),
        ]);

        // Act: APIリクエスト
        $response = $this->postJson('/api/v1/auth/login', [
            'email' => 'test@example.com',
            'password' => 'password123',
        ]);

        // Assert: レスポンス検証
        $response->assertStatus(200)
                 ->assertJsonStructure([
                     'data' => [
                         'user' => ['user_id', 'email', 'nickname'],
                         'token',
                     ],
                     'meta' => ['timestamp'],
                 ]);
    }

    /** @test */
    public function メールアドレスが間違っている場合ログインが失敗する()
    {
        $response = $this->postJson('/api/v1/auth/login', [
            'email' => 'wrong@example.com',
            'password' => 'password123',
        ]);

        $response->assertStatus(401)
                 ->assertJson([
                     'error' => [
                         'code' => 'E-401-02',
                         'message' => 'メールアドレスまたはパスワードが正しくありません',
                     ],
                 ]);
    }
}
```

### 単体テスト例

**ファイル:** `tests/Unit/Utils/DistanceCalculatorTest.php`

```php
<?php

namespace Tests\Unit\Utils;

use Tests\TestCase;
use App\Utils\DistanceCalculator;

class DistanceCalculatorTest extends TestCase
{
    /** @test */
    public function 東京駅と大阪駅の距離が正しく計算される()
    {
        // 東京駅: 35.681236, 139.767125
        // 大阪駅: 34.702485, 135.495951
        $distance = DistanceCalculator::calculate(
            35.681236,
            139.767125,
            34.702485,
            135.495951
        );

        // 約400km (400000m) であることを許容範囲10kmで検証
        $this->assertEqualsWithDelta(400000, $distance, 10000);
    }

    /** @test */
    public function 500メートル以内の判定が正しく動作する()
    {
        // 東京駅: 35.681236, 139.767125
        // 東京駅から約200m離れた地点: 35.682236, 139.767125
        $isWithin = DistanceCalculator::isWithinRange(
            35.681236,
            139.767125,
            35.682236,
            139.767125,
            500
        );

        $this->assertTrue($isWithin);
    }
}
```

## 14.3 Flutter テスト設計

### テストフレームワーク

- **flutter_test** (Flutter標準)
- **mockito** (モック作成)
- **flutter_riverpod** (Providerテスト)

### テストディレクトリ構造

```
test/
├── unit/                 # 単体テスト
│   ├── providers/
│   │   ├── login_provider_test.dart
│   │   └── game_list_provider_test.dart
│   └── utils/
│       └── distance_calculator_test.dart
├── widget/               # Widgetテスト
│   ├── login_screen_test.dart
│   └── game_card_test.dart
└── integration/          # 統合テスト
    └── login_flow_test.dart
```

### Providerテスト例 (単体テスト)

**ファイル:** `test/unit/providers/login_provider_test.dart`

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  group('LoginProvider', () {
    test('ログインが成功するとトークンが保存される', () async {
      // Arrange
      final mockApiClient = MockApiClient();
      final mockTokenStorage = MockTokenStorage();
      
      when(mockApiClient.post(any, any)).thenAnswer((_) async => {
        'data': {
          'token': 'test_token_123',
        }
      });

      final container = ProviderContainer(
        overrides: [
          apiClientProvider.overrideWithValue(mockApiClient),
          tokenStorageProvider.overrideWithValue(mockTokenStorage),
        ],
      );

      // Act
      await container.read(loginProvider.notifier).login(
        'test@example.com',
        'password123',
      );

      // Assert
      verify(mockTokenStorage.save('test_token_123')).called(1);
    });
  });
}
```

### Widgetテスト例

**ファイル:** `test/widget/login_screen_test.dart`

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('ログインボタンが正しく表示される', (WidgetTester tester) async {
    // Arrange & Act
    await tester.pumpWidget(
      MaterialApp(
        home: LoginScreen(),
      ),
    );

    // Assert
    expect(find.text('ログイン'), findsOneWidget);
    expect(find.byType(ElevatedButton), findsOneWidget);
  });

  testWidgets('メールアドレスとパスワードを入力するとログインボタンが活性化する', 
    (WidgetTester tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: LoginScreen(),
      ),
    );

    // ログインボタンが最初は非活性
    final loginButton = find.byType(ElevatedButton);
    expect(tester.widget<ElevatedButton>(loginButton).enabled, isFalse);

    // メールアドレスを入力
    await tester.enterText(
      find.byKey(Key('email_field')),
      'test@example.com',
    );
    await tester.pump();

    // パスワードを入力
    await tester.enterText(
      find.byKey(Key('password_field')),
      'password123',
    );
    await tester.pump();

    // ログインボタンが活性化
    expect(tester.widget<ElevatedButton>(loginButton).enabled, isTrue);
  });
}
```

## 14.4 テスト実行方法

### Laravel

```bash
# 全テスト実行
php artisan test

# 特定のテストファイルのみ実行
php artisan test tests/Feature/Auth/LoginTest.php

# カバレッジ計測
php artisan test --coverage
```

### Flutter

```bash
# 全テスト実行
flutter test

# 特定のテストファイルのみ実行
flutter test test/unit/providers/login_provider_test.dart

# カバレッジ計測
flutter test --coverage
```

## 14.5 CI/CDパイプラインでのテスト自動化

### GitHub Actions設定例

**ファイル:** `.github/workflows/test.yml`

```yaml
name: Run Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  laravel-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
      - name: Install Dependencies
        run: composer install
      - name: Run Tests
        run: php artisan test --coverage

  flutter-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.16.0'
      - name: Install Dependencies
        run: flutter pub get
      - name: Run Tests
        run: flutter test --coverage
```

### 詳細設計への共通コンテキスト（第14章）

**後続タスク（詳細設計）への指示:**

#### テストケースの作成

「14.2. Laravel テスト設計」「14.3. Flutter テスト設計」に基づき、全18機能のAPIテストとWidget テストを作成してください。

特に重要なビジネスロジック（チェックイン判定、距離計算など）は単体テストで100%カバーするようにしてください。

#### CI/CDパイプラインの構築

「14.5. CI/CDパイプラインでのテスト自動化」に基づき、GitHub Actionsの設定ファイルを作成し、プルリクエスト時に自動的にテストが実行されるようにしてください。

---

**第13章と第14章は以上となります。**
