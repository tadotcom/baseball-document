# 第11章 バッチ処理設計

本システムは、サーバー側 (Laravel) で定期的に実行されるバッチ処理（スケジュールタスク）を定義する。

## 11.1 バッチ処理一覧

| バッチ名 | 実行頻度 | 実行時刻 | 処理内容 | 対応コマンド |
|---|---|---|---|---|
| 試合ステータス自動更新 | 毎日1回 | 02:00 | 試合日時を過ぎた「募集中」「満員」の試合を「開催済み」に更新 | `games:update-status` |
| 試合開催前日リマインダー | 毎日1回 | 20:00 | 翌日開催予定の試合の全参加者にプッシュ通知とメールを送信 | `games:send-reminder` |
| トークンクリーンアップ | 毎日1回 | 03:00 | 有効期限切れのトークンを削除 | `tokens:cleanup` |

## 11.2 バッチ処理の実装コード

### 1. 試合ステータス自動更新バッチ

試合日時を過ぎた「募集中」「満員」の試合を「開催済み」に自動更新する。

**ファイル:** `app/Console/Commands/UpdateGameStatus.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Game;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class UpdateGameStatus extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'games:update-status';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = '試合ステータスを自動更新(募集中/満員→開催済み)';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 固定ルール: 試合開始1時間後を「開催済み」とする
        $thresholdTime = Carbon::now()->subHour(1);

        // 試合開始1時間後を過ぎていて、かつステータスが「募集中」または「満員」の試合
        $gamesToUpdate = Game::where('game_date_time', '<=', $thresholdTime)
                             ->whereIn('status', ['募集中', '満員'])
                             ->get();

        if ($gamesToUpdate->isEmpty()) {
            Log::info('[BATCH END] 更新対象の試合はありませんでした。');
            return 0;
        }

        $count = 0;
        foreach ($gamesToUpdate as $game) {
            // 固定ルール: 排他制御のためDBロック (SELECT ... FOR UPDATE) を使用
            $game = Game::where('id', $game->id)->lockForUpdate()->first();

            // ステータスを「開催済み」に更新
            $game->status = '開催済み';
            $game->save();

            Log::info("[GAME STATUS UPDATED] Game ID: {$game->id}, Status: 開催済み");
            $count++;
        }

        Log::info("[BATCH END] {$count}件の試合ステータスを更新しました。");
        $this->info("{$count}件の試合ステータスを更新しました。");

        return 0;
    }
}
```

### 2. 試合開催前日リマインダーバッチ

翌日開催予定の試合の全参加者にプッシュ通知とメールを送信する。

**ファイル:** `app/Console/Commands/SendGameReminder.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Game;
use App\Models\Participation;
use App\Notifications\GameReminder;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class SendGameReminder extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'games:send-reminder';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = '試合開催前日リマインダーを送信';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 翌日（明日）の日付範囲を取得
        $tomorrow = Carbon::tomorrow();
        $tomorrowStart = $tomorrow->startOfDay();
        $tomorrowEnd = $tomorrow->endOfDay();

        // 翌日に開催予定の試合を取得
        $games = Game::whereBetween('game_date_time', [$tomorrowStart, $tomorrowEnd])
                     ->whereIn('status', ['募集中', '満員'])
                     ->get();

        if ($games->isEmpty()) {
            Log::info('[BATCH END] 翌日に開催予定の試合はありませんでした。');
            return 0;
        }

        $totalNotificationsSent = 0;

        foreach ($games as $game) {
            // 該当試合の全参加者を取得
            $participations = Participation::where('game_id', $game->id)
                                           ->with('user')
                                           ->get();

            foreach ($participations as $participation) {
                $user = $participation->user;

                // プッシュ通知とメールを送信 (GameReminder Notification)
                try {
                    $user->notify(new GameReminder($game));
                    Log::info("[REMINDER SENT] User ID: {$user->id}, Game ID: {$game->id}");
                    $totalNotificationsSent++;
                } catch (\Exception $e) {
                    Log::error("[REMINDER FAILED] User ID: {$user->id}, Game ID: {$game->id}, Error: {$e->getMessage()}");
                }
            }
        }

        Log::info("[BATCH END] {$totalNotificationsSent}件のリマインダーを送信しました。");
        $this->info("{$totalNotificationsSent}件のリマインダーを送信しました。");

        return 0;
    }
}
```

### 3. トークンクリーンアップバッチ

有効期限切れのトークンを削除する。

**ファイル:** `app/Console/Commands/CleanupTokens.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Laravel\Sanctum\PersonalAccessToken;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class CleanupTokens extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'tokens:cleanup';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = '有効期限切れのトークンを削除';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 固定ルール: トークンの有効期限は24時間
        $expirationTime = Carbon::now()->subHours(24);

        // created_at が24時間以上前のトークンを削除
        $deletedCount = PersonalAccessToken::where('created_at', '<', $expirationTime)
                                           ->delete();

        if ($deletedCount === 0) {
            Log::info('[BATCH END] 削除対象のトークンはありませんでした。');
            return 0;
        }

        Log::info("[BATCH END] {$deletedCount}件のトークンを削除しました。");
        $this->info("{$deletedCount}件のトークンを削除しました。");

        return 0;
    }
}
```

## 11.3 スケジュール登録

Laravel の Task Scheduling 機能を使用してバッチ処理を登録する。

**ファイル:** `app/Console/Kernel.php`

```php
<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    /**
     * Define the application's command schedule.
     */
    protected function schedule(Schedule $schedule): void
    {
        // 1. 試合ステータス自動更新: 毎日02:00に実行
        $schedule->command('games:update-status')
                 ->dailyAt('02:00')
                 ->withoutOverlapping()  // 多重起動を防止
                 ->onOneServer();        // 複数サーバー環境での重複実行を防止

        // 2. 試合開催前日リマインダー: 毎日20:00に実行
        $schedule->command('games:send-reminder')
                 ->dailyAt('20:00')
                 ->withoutOverlapping()
                 ->onOneServer();

        // 3. トークンクリーンアップ: 毎日03:00に実行
        $schedule->command('tokens:cleanup')
                 ->dailyAt('03:00')
                 ->withoutOverlapping()
                 ->onOneServer();
    }

    /**
     * Register the commands for the application.
     */
    protected function commands(): void
    {
        $this->load(__DIR__.'/Commands');

        require base_path('routes/console.php');
    }
}
```

## 11.4 Cron設定 (サーバー側)

Laravel のスケジューラーを動作させるため、Xserver VPS上でCronを設定する。

**Cron設定コマンド:**

```bash
crontab -e
```

**追加する行:**

```
* * * * * cd /path/to/your/laravel/project && php artisan schedule:run >> /dev/null 2>&1
```

**説明:**

- 毎分、Laravel の `schedule:run` コマンドを実行する
- Laravel側で定義したスケジュールタスクが、該当する時刻に実行される

## 11.5 ログ出力

### ログファイル

バッチ処理のログは、Laravel の標準ログ機能を使用して以下に出力される:

**ログファイルパス:** `storage/logs/laravel.log`

### ログフォーマット

各バッチ処理は以下のフォーマットでログを出力する:

```
[2025-10-24 02:00:00] local.INFO: [BATCH START] 試合ステータスを自動更新(募集中/満員→開催済み)
[2025-10-24 02:00:05] local.INFO: [GAME STATUS UPDATED] Game ID: abc-123, Status: 開催済み
[2025-10-24 02:00:10] local.INFO: [BATCH END] 5件の試合ステータスを更新しました。
```

### ログレベル

- **INFO:** 正常な処理の開始・終了
- **WARNING:** 想定内の異常（例: 更新対象なし）
- **ERROR:** 想定外のエラー（例: 通知送信失敗）

---

# 第12章 ログ設計

## 12.1 ログ出力方針

### 目的

- **監視:** システムの正常稼働を確認
- **トラブルシューティング:** エラー発生時の原因調査
- **セキュリティ監査:** 不正アクセスや異常な操作の検出

### 出力対象

以下の操作・イベントをログに記録する:

| カテゴリ | 対象操作 | ログレベル |
|---|---|---|
| 認証 | ログイン成功/失敗、ログアウト、パスワードリセット | INFO / WARNING |
| 認可 | 権限エラー (403) | WARNING |
| API | 全APIリクエスト (エンドポイント、HTTPメソッド、ステータスコード) | INFO |
| エラー | 500系エラー、例外発生 | ERROR |
| セキュリティ | 連続ログイン失敗 (5回以上)、管理者操作 (強制退会など) | WARNING / INFO |
| バッチ | バッチ処理の開始/終了、処理件数 | INFO |

## 12.2 ログフォーマット

### JSON形式

ログはJSON形式で出力し、ログ解析ツール（Elasticsearch、Logstashなど）での処理を容易にする。

**設定ファイル:** `config/logging.php`

```php
'daily' => [
    'driver' => 'daily',
    'path' => storage_path('logs/laravel.log'),
    'level' => env('LOG_LEVEL', 'debug'),
    'days' => 14,
    'formatter' => \Monolog\Formatter\JsonFormatter::class,  // JSON形式
],
```

### ログ出力例

```json
{
  "timestamp": "2025-10-24T02:15:00+09:00",
  "level": "INFO",
  "message": "ログイン成功",
  "context": {
    "user_id": "c3e9c7f6-1f3a-4b9c-8e4a-5a6b7c8d9e0f",
    "email": "user@example.com",
    "ip_address": "192.168.1.100",
    "user_agent": "Mozilla/5.0..."
  }
}
```

## 12.3 ログ記録対象の具体例

### 1. ログイン成功

**トリガー:** F-USR-002 (ログイン) 成功時

**ログレベル:** INFO

**実装:**

```php
Log::info('ログイン成功', [
    'user_id' => $user->id,
    'email' => $user->email,
    'ip_address' => $request->ip(),
    'user_agent' => $request->userAgent(),
]);
```

### 2. ログイン失敗

**トリガー:** F-USR-002 (ログイン) 失敗時 (401エラー)

**ログレベル:** WARNING

**実装:**

```php
Log::warning('ログイン失敗', [
    'email' => $request->email,
    'ip_address' => $request->ip(),
    'error_code' => 'E-401-02',
]);
```

### 3. 連続ログイン失敗

**トリガー:** 同一IPアドレスから5回以上連続してログイン失敗

**ログレベル:** WARNING

**実装:**

```php
Log::warning('連続ログイン失敗', [
    'ip_address' => $request->ip(),
    'attempt_count' => 5,
    'email' => $request->email,
]);
```

### 4. 権限エラー (403)

**トリガー:** 管理者機能への一般ユーザーアクセス

**ログレベル:** WARNING

**実装:**

```php
Log::warning('権限エラー', [
    'user_id' => $user->id,
    'email' => $user->email,
    'endpoint' => $request->path(),
    'error_code' => 'E-403-01',
]);
```

### 5. 500系エラー

**トリガー:** 予期しないサーバーエラー

**ログレベル:** ERROR

**実装:**

```php
Log::error('サーバーエラー', [
    'error_message' => $exception->getMessage(),
    'stack_trace' => $exception->getTraceAsString(),
    'endpoint' => $request->path(),
    'user_id' => $user ? $user->id : null,
]);
```

### 6. 管理者操作 (強制退会)

**トリガー:** F-ADM-003 (ユーザー強制退会)

**ログレベル:** INFO

**実装:**

```php
Log::info('ユーザー強制退会', [
    'admin_id' => $admin->id,
    'admin_email' => $admin->email,
    'target_user_id' => $targetUser->id,
    'target_email' => $targetUser->email,
]);
```

## 12.4 ログローテーション

### ローテーション設定

- **方式:** 日次ローテーション (`daily` driver)
- **保存期間:** 14日間
- **ファイル名:** `laravel-YYYY-MM-DD.log`

**設定ファイル:** `config/logging.php`

```php
'daily' => [
    'driver' => 'daily',
    'path' => storage_path('logs/laravel.log'),
    'level' => env('LOG_LEVEL', 'debug'),
    'days' => 14,  // 14日間保存
],
```

### ディスク容量管理

- ログファイルが14日を超えたものは自動的に削除される
- 必要に応じて、古いログをバックアップストレージ（S3など）に移動する運用を検討

## 12.5 ログ監視

### 監視対象

以下のログを重点的に監視する:

1. **連続ログイン失敗** (5回以上)
2. **権限エラー (403)** の多発
3. **500系エラー** の発生
4. **バッチ処理の失敗**

### アラート設定

ログ監視ツール（例: Elasticsearch + Kibana、CloudWatch Logs）を使用し、以下の条件でアラートを発報する:

- **連続ログイン失敗:** 1時間以内に同一IPから10回以上
- **500系エラー:** 5分以内に10回以上
- **バッチ処理失敗:** バッチ終了ログが予定時刻から30分経っても記録されない

### 詳細設計への共通コンテキスト（第12章）

**後続タスク（詳細設計）への指示:**

#### ログ出力の実装

「12.3. ログ記録対象の具体例」に基づき、各Controller、Service、Middlewareの該当箇所に `Log::info()` / `Log::warning()` / `Log::error()` を実装してください。

特にセキュリティ関連のログ（ログイン失敗、権限エラー）は漏れなく記録するようにしてください。

#### ログ監視の設定

「12.5. ログ監視」に基づき、ログ監視ツール（Elasticsearch、CloudWatch Logs等）の設定とアラートルールを定義してください。

---

**第11章と第12章は以上となります。**
