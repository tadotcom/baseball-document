# 第11章 バッチ処理設計本システムは、サーバー側 (Laravel) で定期的に実行されるバッチ処理（スケジュールタスク）を定義する。11.1. バッチ処理の実装コード1. 試合ステータス自動更新バッチ試合日時を過ぎた「募集中」「満員」の試合を「開催済み」に自動更新する。ファイル: app/Console/Commands/UpdateGameStatus.php 1```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Game;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class UpdateGameStatus extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'games:update-status'; [cite: 44]

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = '試合ステータスを自動更新(募集中/満員→開催済み)'; [cite: 44]

    /**
     * Execute the console command.
     */
    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 固定ルール: 試合開始1時間後を「開催済み」とする
        $thresholdTime = Carbon::now()->subHour(1);

        // 試合開始1時間後を過ぎていて、かつステータスが「募集中」または「満員」の試合
        $gamesToUpdate = Game::where('game_date_time', '<=', $thresholdTime)
                             ->whereIn('status', ['募集中', '満員'])
                             ->get();

        if ($gamesToUpdate->isEmpty()) {
            Log::info('[BATCH END] 更新対象の試合はありませんでした。');
            return 0;
        }

        $count = 0;
        foreach ($gamesToUpdate as $game) {
            // 固定ルール: 排他制御のためDBロック (SELECT ... FOR UPDATE) を使用
            // ※ここでは簡略化のため、1件ずつトランザクション内で処理
            try {
                \DB::transaction(function () use ($game) {
                    // 再度ロックしてステータスを確認（同時実行防止）
                    $lockedGame = Game::where('game_id', $game->game_id)->lockForUpdate()->first();
                    
                    if (in_array($lockedGame->status, ['募集中', '満員'])) {
                        $lockedGame->status = '開催済み';
                        $lockedGame->save();
                    }
                });
                $count++;
            } catch (\Exception $e) {
                Log::error('[BATCH ERROR] 試合ステータス更新失敗 (GameID: ' . $game->game_id . ')', ['exception' => $e->getMessage()]);
            }
        }
```

        Log::info('[BATCH END] ' . $count . '件の試合ステータスを「開催済み」に更新しました。');
        return 0;
    }
}
2. プッシュ通知配信バッチ (試合リマインダー)試合開始1時間前の参加者に対して、リマインダープッシュ通知 (PUSH-003) を送信する。ファイル: app/Console/Commands/SendGameReminder.php```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Game;
use App\Models\User;
use App\Notifications\GameReminder; // (※第10章で定義)
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class SendGameReminder extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'notifications:send-reminder';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = '試合開始1時間前の参加者にリマインダー通知を送信';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 1時間後?1時間10分後に開始される試合を対象 (cronの実行間隔を考慮)
        $startTime = Carbon::now()->addHour();
        $endTime = Carbon::now()->addHour()->addMinutes(10);

        $games = Game::where('status', '募集中')
                     ->orWhere('status', '満員')
                     ->whereBetween('game_date_time', [$startTime, $endTime])
                     ->with('participants.user') // N+1問題回避
                     ->get();

        if ($games->isEmpty()) {
            Log::info('[BATCH END] 通知対象の試合はありませんでした。');
            return 0;
        }

        $totalUsers = 0;
        foreach ($games as $game) {
            foreach ($game->participants as $participation) {
                $user = $participation->user;
                if ($user && $user->deviceTokens()->exists()) {
                    try {
                        // UserモデルにNotificationを送信
                        $user->notify(new GameReminder($game));
                        $totalUsers++;
                    } catch (\Exception $e) {
                        Log::error('[BATCH ERROR] リマインダー通知送信失敗 (UserID: ' . $user->user_id . ')', ['exception' => $e->getMessage()]);
                    }
                }
            }
        }
```

        Log::info('[BATCH END] ' . $totalUsers . '人のユーザーにリマインダー通知を送信しました。');
        return 0;
    }
}

## 11.2 cronスケジュール設定1. Laravelスケジューラーの設定app/Console/Kernel.php ファイルに、バッチ処理のスケジュールを定義する。```php
<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    /**
     * Define the application's command schedule.
     */
    protected function schedule(Schedule $schedule): void
    {
        // 試合ステータス自動更新バッチ(毎時0分実行) 
        $schedule->command('games:update-status') [cite: 47]
             ->cron('0 * * * *') [cite: 47] // 毎時0分
             ->withoutOverlapping() [cite: 47] // 重複実行防止
             ->runInBackground(); [cite: 47]

        // 試合リマインダー通知バッチ(毎10分実行)
        $schedule->command('notifications:send-reminder')
             ->cron('*/10 * * * *') // 毎10分
             ->withoutOverlapping()
             ->runInBackground();
        
        // (固定ルール: 論理削除60日後物理削除)
        // 個人情報（退会ユーザー）物理削除バッチ (毎日深夜3時実行)
        $schedule->command('model:prune', [
            '--model' => [\App\Models\User::class],
            '--until' => now()->subDays(60) // 60日以上前に論理削除されたもの
        ])->dailyAt('03:00');
    }

    /**
     * Register the commands for the application.
     */
    protected function commands(): void
    {
        $this->load(__DIR__.'/Commands');
        require base_path('routes/console.php');
    }
}
2. システムcronの設定サーバー (Xserver VPS) のcrontabに、Laravelスケジューラーを毎分実行するための設定を追加する。Bash# sudo crontab -e
# 以下を追加:
* * * * * cd /var/www/grass-baseball-matching && php artisan schedule:run >> /dev/null 2>&1

## 11.3 エラーハンドリング排他制御:固定ルール に基づき、データベースロック (SELECT ... FOR UPDATE) を使用し、更新対象のレコードをロックする。Laravelスケジューラーの withoutOverlapping() 2 を使用し、バッチ処理自体の多重起動を防止する。ロギング:バッチ処理の開始時と終了時に INFO レベルのログを出力する。個別の処理（例: 通知送信、ステータス更新）でエラーが発生した場合、ERROR レベルでログ（エラーメッセージ、対象ID）を記録する（Log::error()）。リトライ:バッチ処理全体のリトライは行わず、失敗した処理はログに記録し、手動対応または次回のバッチ実行に委ねる。外部API（FCM）呼び出しの失敗時は、ログに記録するが、バッチ処理自体は継続する。詳細設計への共通コンテキスト（第11章）後続タスク（詳細設計）への指示:コマンドクラスの実装:「11.1. バッチ処理の実装コード」に基づき、UpdateGameStatus.php と SendGameReminder.php の2つのコマンドクラスを app/Console/Commands/ 配下に実装してください。Kernelクラスの編集:「11.2. スケジュール設定」に基づき、app/Console/Kernel.php の schedule メソッドを編集し、定義されたスケジュールを登録してください。個人情報削除バッチの実装:User モデル（App\Models\User）に Prunable トレイトを追加し、pruning() メソッドを実装して、deleted_at が60日以前のレコードを物理削除の対象とするよう定義してください。運用手順書への記載:システム crontab の設定（php artisan schedule:run）を、後続で作成する「運用手順書」または「デプロイ設計書（16章）」に必ず記載してください。第12章 ログ設計12.1. ログ種別要件定義書 3 および 固定ルール に基づき、以下のログを出力する。アクセスログ (Access Log):内容: 全てのAPIリクエストの記録。目的: トラフィック分析、不正アクセスの追跡。出力先: Nginxのログファイル（access.log）エラーログ (Error Log):内容: アプリケーション例外（5xx系）、キャッチされたエラー（4xx系の一部）、バッチ処理エラー。目的: 障害検知、デバッグ。出力先: Laravelのログ（laravel.log または stderr）操作ログ (Operation/Audit Log):内容: 重要なビジネスイベント（ログイン、退会、試合登録、参加、チェックインなど）。目的: ユーザーの操作追跡、セキュリティ監査。出力先: Laravelのログ（laravel.log または stderr）12.2. ログ出力項目 (JSONスキーマ)固定ルール に従い、Laravelが出力するログ（エラーログ、操作ログ）はすべてJSON形式で統一する。1. アクセスログ (Nginx)Nginx側で log_format を設定し、JSON形式で出力する。```json
{
  "timestamp": "2025-10-24T02:30:01+09:00",
  "level": "INFO",
  "type": "access",
  "method": "POST",
  "path": "/api/v1/auth/login",
  "status": 200,
  "duration_ms": 245,
  "ip_address": "192.168.1.1",
  "user_agent": "Mozilla/5.0...",
  "user_id": "c3e9c7f6-..."
}
```

user_id: 認証成功後、LaravelからNginxに渡す（任意）。2. エラーログ (Laravel)APP_LOG_CHANNEL=stack を設定し、Monolog を使用してJSON形式で出力する。```json
{
  "timestamp": "2025-10-24T02:35:05Z",
  "level": "ERROR",
  "message": "通知の配信に失敗しました",
  "context": {
    "error_code": "E-500-01",
    "user_id": "admin-user-id",
    "exception_class": "App\\Exceptions\\FcmFailedException",
    "trace": "[...stack trace...]"
  },
  "channel": "production"
}
3. 操作ログ (Laravel)Log::info() または Log::notice() を使用し、JSON形式で出力する。```json
{
  "timestamp": "2025-10-24T02:30:02Z",
  "level": "INFO",
  "message": "User logged in",
  "context": {
    "user_id": "c3e9c7f6-...",
    "email": "user@example.com",
    "ip_address": "192.168.1.1"
  },
  "channel": "production"
}

## 12.3 ログレベル定義固定ルール に基づき、以下のレベルを使い分ける。レベル用途DEBUG開発時のデバッグ情報。（本番環境では出力しない APP_DEBUG=false）INFO通常の動作ログ。アクセスログ、操作ログ（ログイン、登録など）、バッチ処理の開始/終了。NOTICEINFO より重要だが、エラーではない通知。WARNING警告。処理は継続するが、注意が必要な状態（例: 非推奨APIの使用）。ERRORエラー。処理は失敗したが、アプリケーションは停止しない（例: バリデーション失敗、API連携失敗、DB更新失敗）。CRITICAL致命的なエラー。システムの一部または全体が停止する可能性がある（例: DB接続不可、FCM設定ファイル欠落）。ALERTCRITICAL より深刻。即時対応が必要。EMERGENCYシステムダウン。12.4. ログ保存期間・ローテーション非機能要件:ログ保持期間: 30日間 4実装:Laravelログ: .env で LOG_CHANNEL=daily を設定し、日次でファイルを分割する。Nginxログ: logrotate (Linux標準機能) を使用し、日次でローテーション (daily) し、30世代 (rotate 30) 保持する設定を行う。詳細設計への共通コンテキスト（第12章）後続タスク（詳細設計）への指示:ロギング設定 (Laravel):config/logging.php を設定し、本番環境 (production) チャンネルが stderr または daily に向けられ、JsonFormatter を使用するよう構成してください。操作ログの実装:「12.1. 操作ログ」で定義した重要なビジネスイベント（ログイン、退会、試合登録など）が発生する Service クラスのメソッド内に、Log::info() または Log::notice() を使用したログ出力処理（「12.2. JSONスキーマ」準拠）を実装してください。例外処理の実装:app/Exceptions/Handler.php を編集し、キャッチした例外（AuthenticationException, ValidationException, NotFoundHttpException など）を「12.2. エラーログ」のフォーマットで記録するよう実装してください。E-XXX-XX のエラーコードがログに含まれるよう、カスタム例外クラスまたは Log::error の context に含める処理を追加してください。logrotate設定:「16. デプロイ設計」または「運用手順書」に、Nginxのログローテーション（/etc/logrotate.d/nginx）の設定内容（daily, rotate 30, compress など）を具体的に記載してください。第11章と第12章は以上となります。