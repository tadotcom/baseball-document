# 第7章 セキュリティ設計

## 7.1 認証フロー詳細

固定ルール（2.3. 通信方式）に基づき、以下の認証フローを実行する。

### ログイン (F-USR-002)

1. クライアントが `POST /api/v1/auth/login` に `email` と `password` を送信
2. サーバーは `users` テーブルの `password` を Bcrypt で検証
3. 成功時、Laravel Sanctum が Personal Access Token (PAT) を生成（有効期限24時間）
4. サーバーはHTTP 200でトークンを返却

### トークン検証 (全認証必須API)

1. クライアントは `Authorization: Bearer {token}` ヘッダーを付与してAPIリクエスト
2. サーバー (Laravel) の `auth:sanctum` ミドルウェアがトークンを検証
3. トークンが無効または期限切れの場合、HTTP 401 (E-401-01) を返却
4. クライアントはHTTP 401受信時、`flutter_secure_storage` からトークンを削除し、ログイン画面 (SCR-USR-001) に強制遷移させる

### リフレッシュ

- リフレッシュトークンは使用しない（固定ルール）
- トークン（有効期限24時間）が切れた場合は、必ず再ログインを要求する

### ログアウト (F-USR-003)

1. クライアントが `POST /api/v1/auth/logout` を（有効なトークンで）呼び出す
2. サーバーは該当の PAT をデータベースから削除（無効化）する
3. クライアントは `flutter_secure_storage` からトークンを削除し、ログイン画面 (SCR-USR-001) に遷移する

## 7.2 認可フロー詳細

### ユーザー種別

- **一般ユーザー** と **管理者** の2種類が存在する

### 認可方式

Laravel のミドルウェアを用いて認可制御する。

#### 一般ユーザー

- `auth:sanctum` ミドルウェアのみ
- 自身の `user_id` に紐づくリソース（例: 参加登録、ログアウト）のみ操作可

#### 管理者

- `/api/v1/admin/*` のエンドポイント（F-ADM-001~010）には、`auth:sanctum` に加えて `AdminMiddleware` を適用する
- `AdminMiddleware` は、認証済みユーザーが管理者権限を持つか（例: `users` テーブルの `role` カラム、または特定の email リスト）を判定し、権限がない場合は HTTP 403 (E-403-01) を返却する

## 7.3 パスワード管理

### ハッシュ化アルゴリズム

- **Bcrypt** （固定ルール）

### Laravel実装

- `Hash::make($password)` を使用してハッシュ化し、`Hash::check($plainPassword, $hashedPassword)` で検証する
- **コストパラメータ:** 10 (Laravel デフォルト)
- **ソルト:** Bcrypt に自動的に含まれるため、別途ソルトカラムは用意しない
- **DB保存:** `users.password` カラム (VARCHAR(255)) にハッシュ値を保存する

## 7.4 トークン保存方式 (Flutter)

### 採用パッケージ

- **flutter_secure_storage** （固定ルール）

### 保存場所

- **iOS:** Keychain
- **Android:** EncryptedSharedPreferences (AES暗号化)

### 目的

トークンを平文でローカルストレージ（SharedPreferencesなど）に保存することを防ぎ、デバイス固有の安全な領域に格納する。

## 7.5 通信暗号化

### プロトコル

- **TLS 1.2以上** を必須とする

### 対象

クライアント (Flutter) とサーバー (Nginx) 間の全API通信。

### 実装

Xserver VPS上でSSL証明書（Let's Encryptなど）を設定し、HTTPS通信を強制する。
（詳細は 16.3. Nginx設定ファイル を参照）

## 7.6 入力値検証

### クライアント側 (Flutter)

**責務:** ユーザービリティ (UX) の向上

**実装:** `TextFormField` の `validator` や Provider で、固定バリデーションルール に基づく形式チェック（必須、文字長、メール形式など）を行う

**目的:** 不正なリクエストを送信する前にユーザーに即時フィードバックを提供し、無駄なAPIコールを削減する

### サーバー側 (Laravel)

**責務:** データの完全性とセキュリティの担保（必須）

**実装:** Laravel FormRequest (`app/Http/Requests/`) を使用し、固定バリデーションルール に基づく全項目の厳密な検証（形式、長さ、一意性制約、存在チェックなど）を行う

**目的:** クライアント側の検証はバイパス可能であるため、サーバー側で必ず全ての入力を信頼せず検証する（ゼロトラスト）

## 7.7 OWASP Top 10対策 (具体的実装方法)

| 脆弱性 | 対策内容 | Laravel実装 (サーバー側) | Flutter実装 (クライアント側) |
|---|---|---|---|
| **A01: アクセス制御の不備** | 認証・認可の徹底 | <ul><li>`auth:sanctum` ミドルウェアで全保護エンドポイントをガード</li><li>`AdminMiddleware` で管理者権限をチェック</li><li>リソース操作時に、`$request->user()->id` と対象リソースの `user_id` が一致するか確認する</li></ul> | <ul><li>トークンを `flutter_secure_storage` に保存</li><li>全APIリクエストに `Authorization` ヘッダーを付与</li><li>401/403受信時にログイン画面へ遷移させる</li></ul> |
| **A02: 暗号化の失敗** | 送信中・保存中のデータ保護 | <ul><li>NginxでTLS 1.2以上を強制。HTTPからHTTPSへリダイレクト</li><li>パスワードはBcryptでハッシュ化（ソルト付き）</li></ul> | <ul><li>API通信はHTTPSのみ許可</li><li>トークンは `flutter_secure_storage` に保存</li></ul> |
| **A03: インジェクション** | 入力値のサニタイズとクエリの分離 | <ul><li>**SQLi:** Eloquent ORM および クエリビルダー を使用（パラメータバインディング）。生SQL (DB::raw, selectRaw 等) を原則禁止</li><li>**XSS:** Bladeテンプレート（管理者画面）では `{{ }}` 構文を使用し、自動的にエスケープする</li></ul> | <ul><li>APIレスポンスをJSONとしてパースし、Widget（Textなど）に表示する（デフォルトでエスケープされる）</li></ul> |
| **A04: 安全でない設計** | セキュア設計原則の適用 | <ul><li>固定ルール に基づくレートリミットを実装（認証: 120回/分、ログイン: 5回/分）</li><li>最小権限の原則に基づき、管理者機能とユーザー機能を明確に分離</li></ul> | <ul><li>(特になし)</li></ul> |
| **A05: セキュリティ設定の不備** | フレームワークとサーバーの堅牢化 | <ul><li>`.env` ファイルで `APP_DEBUG=false` （本番環境）</li><li>Nginx/PHPのバージョン情報をヘッダーから削除</li><li>Composerの依存関係を定期的に更新 (`composer audit`)</li></ul> | - |
| **A06: 脆弱で時代遅れのコンポーネント** | 依存関係の管理 | <ul><li>`composer.json` と `package.json` のライブラリを最新の安定版に保つ</li><li>`composer audit` をCI/CDパイプラインに組み込む</li></ul> | <ul><li>`pubspec.yaml` の依存関係を最新に保つ</li><li>`flutter pub outdated` で定期的に確認</li></ul> |
| **A07: 識別と認証の失敗** | セッション管理の強化 | <ul><li>Sanctumトークンの有効期限を24時間に設定</li><li>リフレッシュトークンを使用せず、期限切れ時は再ログインを強制</li><li>ログアウト時にサーバー側でトークンを無効化</li></ul> | <ul><li>ログアウト時に `flutter_secure_storage` からトークンを確実に削除する</li></ul> |
| **A08: ソフトウェアとデータの完全性の不備** | デシリアライゼーション、CI/CDの保護 | <ul><li>(PHPのデシリアライゼーション脆弱性) 信頼できないソースからの `unserialize()` を禁止</li><li>CI/CDパイプライン（GitHub Actionsなど）のシークレット（.env）を暗号化して管理する</li></ul> | <ul><li>(特になし)</li></ul> |
| **A09: セキュリティログと監視の不備** | イベントの記録とアラート | <ul><li>ログイン成功/失敗、パスワードリセット、強制退会などのセキュリティイベントをログ（JSON形式）に記録（詳細は12章）</li><li>5xx系エラーや401/403の多発を監視（詳細は13章）</li></ul> | <ul><li>(特になし。クライアントログは通常対象外)</li></ul> |
| **A10: サーバーサイドリクエストフォージェリ (SSRF)** | 外部リソースアクセスの制限 | <ul><li>(本システムでは該当機能なし)</li><li>将来的にURLから画像取得などを行う場合は、許可リストベースのドメイン検証を必須とする</li></ul> | <ul><li>(特になし)</li></ul> |

### 詳細設計への共通コンテキスト（第7章）

**後続タスク（詳細設計）への指示:**

#### ミドルウェアの実装

- `auth:sanctum` を `routes/api.php` の認証必須ルートグループに適用してください
- 「7.2. 認可フロー詳細」に基づき、管理者権限をチェックする `AdminMiddleware.php` を作成し、`/api/v1/admin/*` ルートグループに適用してください

#### クライアント側実装 (Flutter)

- 「7.1. 認証フロー詳細」に基づき、HTTP 401エラーをグローバルにハンドリングする処理（APIクライアントやProvider層）を実装し、ログイン画面への強制遷移を行ってください
- `flutter_secure_storage` を使用してトークンを読み書きする `TokenStorageService` クラスを設計・実装してください

#### レートリミットの実装

- 「7.7. OWASP A04」に基づき、Laravel の `RouteServiceProvider` またはミドルウェアで、固定ルール（認証: 120回/分、ログイン: 5回/分）のレートリミットを設定してください

---

# 第8章 外部連携設計

## 8.1 Firebase Cloud Messaging (FCM) 連携

### 設定ファイル配置方法

#### iOS (GoogleService-Info.plist)

1. Firebase Console から `GoogleService-Info.plist` をダウンロード
2. Flutterプロジェクトの `ios/Runner/` ディレクトリに配置する

#### Android (google-services.json)

1. Firebase Console から `google-services.json` をダウンロード
2. Flutterプロジェクトの `android/app/` ディレクトリに配置する

### パッケージ導入

**採用パッケージ:** `firebase_messaging`

**pubspec.yaml に追加:**

```yaml
dependencies:
  firebase_messaging: ^14.0.0  # 最新の安定版を使用
```

### 初期化処理 (Flutter)

アプリ起動時 (`main.dart`) に以下を実行:

```dart
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  
  // FCMトークン取得
  FirebaseMessaging messaging = FirebaseMessaging.instance;
  String? token = await messaging.getToken();
  
  // トークンをサーバーに送信 (POST /api/v1/device-tokens)
  if (token != null) {
    await sendDeviceTokenToServer(token);
  }
  
  runApp(MyApp());
}
```

### デバイストークン登録API (POST /api/v1/device-tokens)

**概要:** クライアントが取得したFCMトークンをサーバーに登録する

**認証:** 必要 (`auth:sanctum`)

**リクエストボディ:**

```json
{
  "device_token": "string(FCMトークン)",
  "platform": "string(ios または android)"
}
```

**レスポンス (成功時 201 Created):**

```json
{
  "data": {
    "device_token_id": "uuid",
    "device_token": "dX3k...",
    "platform": "ios"
  },
  "meta": {
    "timestamp": "2025-10-24T02:15:00Z"
  }
}
```

**Laravel実装:**

- `device_tokens` テーブルに以下を保存:
  - `user_id` (認証済みユーザーのID)
  - `device_token` (FCMトークン)
  - `platform` (ios/android)
- 同一ユーザー・同一トークンの重複登録を防ぐ（`user_id` + `device_token` でユニーク制約）

### 通知送信処理 (Laravel)

#### Laravelパッケージ導入

```bash
composer require kreait/firebase-php
```

#### 設定ファイル配置

1. Firebase Console から「サービスアカウント秘密鍵」(JSON) をダウンロード
2. `storage/app/firebase/` ディレクトリに `service-account.json` として配置
3. `.env` に以下を追加:

```
FIREBASE_CREDENTIALS=storage/app/firebase/service-account.json
```

#### 通知送信コード例

```php
use Kreait\Firebase\Factory;
use Kreait\Firebase\Messaging\CloudMessage;

$factory = (new Factory)->withServiceAccount(storage_path('app/firebase/service-account.json'));
$messaging = $factory->createMessaging();

$message = CloudMessage::withTarget('token', $deviceToken)
    ->withNotification([
        'title' => '試合開催前日です',
        'body' => '明日の試合を忘れずに！',
    ])
    ->withData([
        'game_id' => '12345',
        'click_action' => 'OPEN_GAME_DETAIL'
    ]);

try {
    $messaging->send($message);
} catch (\Exception $e) {
    // エラーログ記録 (E-500-01)
    Log::error('FCM送信失敗', ['error' => $e->getMessage()]);
}
```

### Flutter側での通知受信処理

#### フォアグラウンド通知

```dart
FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  print('フォアグラウンドで通知受信: ${message.notification?.title}');
  
  // アプリ内でSnackBarやダイアログを表示
  showDialog(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(message.notification?.title ?? ''),
      content: Text(message.notification?.body ?? ''),
    ),
  );
});
```

#### バックグラウンド/終了時通知

```dart
FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  print('バックグラウンドで通知受信: ${message.notification?.title}');
}
```

#### 通知タップ時の処理

```dart
FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
  print('通知をタップしてアプリ起動');
  
  // データペイロードに基づいて画面遷移
  String? gameId = message.data['game_id'];
  if (gameId != null) {
    Navigator.pushNamed(context, '/game-detail', arguments: gameId);
  }
});
```

## 8.2 メール送信 (Laravel Mail)

### SMTP設定 (.env)

```
MAIL_MAILER=smtp
MAIL_HOST=smtp.example.com
MAIL_PORT=587
MAIL_USERNAME=your-email@example.com
MAIL_PASSWORD=your-password
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=noreply@grassballapp.com
MAIL_FROM_NAME="${APP_NAME}"
```

### キュー設定

非同期でメール送信を行うため、Laravel Queue を使用:

```
QUEUE_CONNECTION=database
```

マイグレーション実行:

```bash
php artisan queue:table
php artisan migrate
```

### Mailable クラスの作成

**例: アカウント登録完了メール**

```bash
php artisan make:mail AccountRegistered
```

`app/Mail/AccountRegistered.php`:

```php
<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class AccountRegistered extends Mailable
{
    use Queueable, SerializesModels;

    public $user;

    public function __construct($user)
    {
        $this->user = $user;
    }

    public function build()
    {
        return $this->subject('アカウント登録完了')
                    ->view('emails.account_registered');
    }
}
```

### Bladeテンプレート

`resources/views/emails/account_registered.blade.php`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>アカウント登録完了</title>
</head>
<body>
    <h2>ようこそ、{{ $user->nickname }}さん！</h2>
    <p>草野球マッチングへのご登録ありがとうございます。</p>
    <p>アプリをダウンロードして、さっそく試合を探しましょう！</p>
</body>
</html>
```

### メール送信処理

**AuthService.php (ユーザー登録時):**

```php
use App\Mail\AccountRegistered;
use Illuminate\Support\Facades\Mail;

// ユーザー登録後
Mail::to($user->email)->queue(new AccountRegistered($user));
```

## 8.3 Google Maps API 連携 (Flutter)

### APIキー取得

1. Google Cloud Console で Google Maps SDK for Android/iOS を有効化
2. APIキーを取得し、以下に設定:

**Android:** `android/app/src/main/AndroidManifest.xml`

```xml
<manifest ...>
    <application ...>
        <meta-data
            android:name="com.google.android.geo.API_KEY"
            android:value="YOUR_API_KEY_HERE"/>
    </application>
</manifest>
```

**iOS:** `ios/Runner/AppDelegate.swift`

```swift
import GoogleMaps

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GMSServices.provideAPIKey("YOUR_API_KEY_HERE")
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}
```

### パッケージ導入

```yaml
dependencies:
  google_maps_flutter: ^2.5.0
```

### 地図表示 (Flutter)

```dart
import 'package:google_maps_flutter/google_maps_flutter.dart';

GoogleMap(
  initialCameraPosition: CameraPosition(
    target: LatLng(35.6895, 139.6917), // 試合会場の緯度経度
    zoom: 15,
  ),
  markers: {
    Marker(
      markerId: MarkerId('game_venue'),
      position: LatLng(35.6895, 139.6917),
      infoWindow: InfoWindow(
        title: '〇〇グラウンド',
        snippet: '東京都新宿区...',
      ),
    ),
  },
)
```

### 詳細設計への共通コンテキスト（第8章）

**後続タスク（詳細設計）への指示:**

#### FCM実装

- 「8.1. FCM連携」に基づき、デバイストークン登録API (`POST /api/v1/device-tokens`) のController、FormRequest、Serviceを実装してください
- F-ADM-009 (プッシュ通知配信) のController内で、Firebaseライブラリを使用して複数デバイスへの一斉送信処理を実装してください

#### メール実装

- 「8.2. メール送信」に基づき、7種類のMailableクラス（AccountRegistered, PasswordReset等）を実装してください
- 対応するBladeテンプレートを `resources/views/emails/` に作成してください

#### Google Maps実装

- 「8.3. Google Maps API連携」に基づき、試合詳細画面 (SCR-USR-005) に地図表示Widgetを組み込んでください
- 試合会場の緯度経度は `games` テーブルの `latitude` / `longitude` カラムから取得してください
