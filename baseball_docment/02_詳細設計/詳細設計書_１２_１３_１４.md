詳細設計書：草野球マッチングアプリ第12章 ログ設計 (詳細定義)基本設計書 第12章 の「詳細設計への共通コンテキスト」で指示されたタスク（ロギング設定、操作ログ実装、例外処理実装、logrotate設定）に基づき、ログ仕様を以下の通り定義する。12.1. ログ種別 (確定)アクセスログ (Access Log):内容: 全てのAPIリクエストの記録。目的: トラフィック分析、不正アクセスの追跡。出力先: Nginxのログファイル（access.log）エラーログ (Error Log):内容: アプリケーション例外（5xx系）、キャッチされたエラー（4xx系の一部）、バッチ処理エラー。目的: 障害検知、デバッグ。出力先: Laravelのログ（laravel.log または stderr）操作ログ (Operation/Audit Log):内容: 重要なビジネスイベント（ログイン、退会、試合登録、参加、チェックインなど）。目的: ユーザーの操作追跡、セキュリティ監査。出力先: Laravelのログ（laravel.log または stderr）12.2. ログ出力項目 (JSONスキーマ)固定ルール および基本設計書 に従い、Laravelが出力するログ（エラーログ、操作ログ）はすべてJSON形式で統一する。1. アクセスログ (Nginx)Nginxの log_format を設定し、JSON形式で出力する。JSON{
  "timestamp": "2025-10-24T02:30:01+09:00",
  "level": "INFO",
  "type": "access",
  "method": "POST",
  "path": "/api/v1/auth/login",
  "status": 200,
  "duration_ms": 245,
  "ip_address": "192.168.1.1",
  "user_agent": "Mozilla/5.0...",
  "user_id": "c3e9c7f6-..."
}
2. エラーログ (Laravel)Monolog を使用してJSON形式で出力する。JSON{
  "timestamp": "2025-10-24T02:35:05Z",
  "level": "ERROR",
  "message": "通知の配信に失敗しました",
  "context": {
    "error_code": "E-500-01",
    "user_id": "admin-user-id",
    "exception_class": "App\\Exceptions\\FcmFailedException",
    "trace": "[...stack trace...]"
  },
  "channel": "production"
}
3. 操作ログ (Laravel)Log::info() を使用し、JSON形式で出力する。JSON{
  "timestamp": "2025-10-24T02:30:02Z",
  "level": "INFO",
  "message": "User logged in",
  "context": {
    "user_id": "c3e9c7f6-...",
    "email": "user@example.com",
    "ip_address": "192.168.1.1"
  },
  "channel": "production"
}
12.3. ログレベル定義 (確定)固定ルール に基づき、以下のレベルを使い分ける。レベル用途DEBUG開発時のデバッグ情報。（本番環境 APP_DEBUG=false では出力しない）INFO通常の動作ログ。操作ログ（ログイン、登録など）、バッチ処理の開始/終了。WARNING警告。処理は継続するが、注意が必要な状態。ERRORエラー。処理は失敗したが、アプリケーションは停止しない（例: API連携失敗 E-500-01, DB更新失敗）。CRITICAL致命的なエラー。システムの一部または全体が停止する可能性がある（例: DB接続不可）。12.4. ログ保存期間・ローテーション非機能要件: ログ保持期間: 30日間実装 (Laravel): .env で LOG_CHANNEL=daily を設定し、日次でファイルを分割する。実装 (Nginx): logrotate (Linux標準機能) を使用し、日次 (daily) でローテーションし、30世代 (rotate 30) 保持する設定を行う。12.5. コード生成AIへの共通コンテキスト (第12章)目的:第12章の定義に基づき、Laravelのロギング設定、例外ハンドリング、および操作ログの出力を実装する。指示:ロギング設定 (Laravel):config/logging.php を設定し、本番環境 (production) チャンネルが daily（日次ローテーション） に設定され、JsonFormatter を使用するよう構成してください。.env ファイルで LOG_CHANNEL=daily および LOG_LEVEL=info を設定してください。例外ハンドリング (Laravel):app/Exceptions/Handler.php の register メソッドを編集してください。AuthenticationException (認証失敗), ValidationException (バリデーション失敗), NotFoundHttpException (404) などの例外を reportable でキャッチし、「12.2. エラーログ」のフォーマット（error_code を含む）で Log::error() に記録するよう実装してください。APIリクエスト ($request->expectsJson()) の場合、renderable で「5.5. エラーレスポンス統一仕様」 に基づくJSONレスポンスを返すように実装してください。操作ログの実装 (Laravel):「12.1. 操作ログ」で定義した重要なビジネスイベントが発生する Service クラスのメソッド（例: AuthService@login, GameService@createGame, CheckinService@executeCheckin）の 処理成功時 に、「12.2. 操作ログ」のフォーマット（message と context）に従って Log::info() を呼び出す処理を 必ず 実装してください。例 (AuthService@login):PHPLog::info('User logged in', [
    'user_id' => $user->user_id,
    'email' => $user->email,
    'ip_address' => $request->ip()
]);
logrotate設定 (Nginx):第16章 で作成する「環境構築手順書」または「デプロイ手順書」に、Nginxのログローテーション設定（/etc/logrotate.d/nginx）の具体例（daily, rotate 30, compress, delaycompress, notifempty, sharedscripts）を記載してください。第13章 監視設計 (詳細定義)基本設計書 第13章 の「詳細設計への共通コンテキスト」で指示されたタスク（ツール選定、アラート設定、Slack連携、ヘルスチェックAPI実装）に基づき、監視仕様を以下の通り定義する。13.1. 監視項目 (確定)カテゴリ監視項目監視内容リソース監視CPU使用率Xserver VPS のCPU使用率メモリ使用率Xserver VPS のメモリ使用率ディスク使用率Xserver VPS のディスク空き容量可用性監視サービス死活監視/api/v1/health エンドポイントへのHTTP GETが200 OKを返すか（Uptime Robot など）パフォーマンス監視API応答時間95パーセンタイルの応答時間が 1000ms を超過しないか (APMツール)エラー監視5xxエラーレートNginx / Laravel で発生する 5xx系 (サーバーエラー) の発生率 (APMツール)4xxエラーレート401, 403, 429 (認証/認可/レートリミット) エラーの発生率バッチ処理監視バッチ実行ステータスcron (schedule:run) が異常終了しないか13.2. アラート閾値 (確定)非機能要件定義書 および基本設計書 に基づき、以下の閾値を確定する。監視項目閾値 (アラート発報条件)優先度CPU使用率80% が 10分以上継続中メモリ使用率90% が 10分以上継続高ディスク使用率90% を超過高サービス死活監視2回連続で 200 OK 以外を検知 (5xx, タイムアウト)高API応答時間 (95p)1000ms を超過高5xxエラーレート1分あたりの 5xx エラーが 1% を超過高バッチ実行ステータスバッチ処理が異常終了 (終了コード 0 以外)高13.3. 監視ツール (確定)基本設計書 の候補に基づき、以下のツールを選定する。リソース監視: Xserver VPS 標準機能可用性監視: Uptime Robot (外部SaaS、99.5% 監視用)パフォーマンス/エラー監視: New Relic (APMツール、1000ms 監視用)エラー通知: Slack (Laravel Log 連携)13.4. ヘルスチェックAPI実装サービス死活監視のため、認証不要な /api/v1/health エンドポイントを実装する。routes/api.phpPHP<?php
use Illuminate\Support\Facades\Route;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

// ...

Route::get('/health', function () {
    try {
        // 1. DB接続確認
        DB::connection()->getPdo();
        
        // (オプション) 2. Redis接続確認など
        // ...

        return response()->json([
            'status' => 'ok',
            'timestamp' => now()->toIso8601String()
        ], 200);

    } catch (\Exception $e) {
        Log::critical('[HEALTH CHECK FAILED]', ['error' => $e->getMessage()]);
        return response()->json([
            'status' => 'error',
            'message' => 'System health check failed.',
            'details' => $e->getMessage(),
            'timestamp' => now()->toIso8601String()
        ], 503); // 503 Service Unavailable
    }
});
13.5. コード生成AIへの共通コンテキスト (第13章)目的:第13章の定義に基づき、監視用のヘルスチェックAPI、およびエラーログのSlack通知設定を実装する。指示:ヘルスチェックAPIの実装 (Laravel):routes/api.php の 認証不要なルートグループ に、「13.4. ヘルスチェックAPI実装」のコードを 完全に 実装してください。DB::connection()->getPdo() を呼び出して、データベース接続の死活監視を必ず含めてください。失敗時は Log::critical でログを出力し、HTTP 503 を返すようにしてください。APMツール (New Relic) の導入:第16章 で作成する「環境構築手順書」に、New Relic PHP エージェントを Xserver VPS にインストールする手順を記載してください。.env ファイル に NEW_RELIC_LICENSE_KEY と NEW_RELIC_APP_NAME を追加してください。Slack通知設定 (Laravel):config/logging.php の channels に slack チャンネルを追加してください。PHP'slack' => [
    'driver' => 'slack',
    'url' => env('LOG_SLACK_WEBHOOK_URL'),
    'username' => 'Laravel Log',
    'emoji' => ':boom:',
    'level' => env('LOG_SLACK_LEVEL', 'critical'), // critical 以上を通知
],
.env に LOG_SLACK_WEBHOOK_URL（Slack Webhook URL）と LOG_SLACK_LEVEL=critical を追加してください。config/logging.php の stack チャンネルの channels に slack を追加し、本番環境 (production) で critical 以上のログがSlackに通知されるようにしてください。第14章 バックアップ・リカバリ設計 (詳細定義)基本設計書 第14章 の「詳細設計への共通コンテキスト」で指示されたタスク（バックアップスクリプト作成、.env管理、リカバリ手順書作成）に基づき、バックアップ・リカバリ仕様を以下の通り定義する。14.1. バックアップ対象 (確定)データベース: MySQL (grass_baseball_matching スキーマ) の全データ。設定ファイル (最重要):  /var/www/grass-baseball-matching/.env14.2. バックアップ頻度・世代管理 (確定)非機能要件 および基本設計書 に基づき、以下で確定する。対象: データベース (MySQL)実行方法: Xserver VPS 標準の「自動バックアップ」機能を利用する。バックアップ頻度: 日次保持期間: 30日間14.3. リストア手順概要 (DB)非機能要件（MTTR: 24時間以内）を達成するため、Xserver VPSの標準機能 を利用したリストア手順を定義する。障害検知: 監視アラート（第13章）によりDB障害を検知。サービス停止: Xserver VPS 上の Nginx でメンテナンス画面（静的HTML）に切り替え。リストアポイント決定: バックアップ（30日以内）から復旧ポイント（通常は前日）を決定。リストア実行 (Xserver VPS機能):a.  Xserver VPS のコントロールパネルにログイン。b.  「自動バックアップ」メニューから対象サーバーを選択。c.  リストアポイント（日付）を選択し、「MySQL」のリストアを実行。データ整合性確認:a.  php artisan tinker や管理画面（SCR-ADM-001）でデータが正常に復旧しているか確認。サービス再開: Nginx の設定を戻し、メンテナンス画面を解除。14.4. 設定ファイル (.env) の管理.env ファイルはGit管理から除外し、Bitwarden や 1Password などのパスワードマネージャー、または暗号化されたS3バケットに、マスターバージョンを厳重に保管する。14.5. コード生成AIへの共通コンテキスト (第14章)目的:第14章の定義に基づき、データベースのリカバリ手順書、および .env ファイルの管理手順を整備する。指示:バックアップスクリプトの作成:不要。実行方法として「Xserver VPS 標準の「自動バックアップ」機能を利用する」 と決定したため、mysqldump スクリプトの作成は不要です。リカバリ手順書の作成:第16章 で作成する「運用手順書」に、「14.3. リストア手順概要」に基づいた**「データベースリカバリ手順書」**を 必ず 含めてください。手順書には、Xserver VPS コントロールパネルのスクリーンショットや、具体的なクリック箇所を明記し、MTTR 24時間以内 を達成できるよう、緊急時に誰でも実行可能なレベルの詳細度で記載してください。.env 管理手順の作成:「運用手順書」に、**「.env ファイル管理手順」**を設けてください。「14.4.」の指示（パスワードマネージャー等でのマスターバージョン保管）と、サーバー構築時にマスターバージョンから .env ファイルをサーバー（/var/www/grass-baseball-matching/.env）にデプロイする（例: scp や手動コピー）手順を明記してください。