# 詳細設計書：草野球マッチングアプリ

## 第9章 位置情報・チェックイン機能設計 (詳細定義)

基本設計書 第9章 の「詳細設計への共通コンテキスト」で指示されたタスク（Flutter実装、Laravel実装）に基づき、F-USR-008（チェックイン機能） の詳細仕様を以下の通り定義する。

### 9.1 位置情報取得方式 (Flutter)

**採用パッケージ:** `geolocator`

**要求精度:** `LocationAccuracy.high` （高精度GPS）

**権限要求フロー:**

1. ユーザーが SCR-USR-005（試合詳細） で「チェックイン」ボタンをタップ
2. CheckinRepository (または Provider) が `geolocator.checkPermission()` を呼び出す
3. `denied` の場合: `geolocator.requestPermission()` を呼び出し、OSの許可ダイアログを表示
4. `deniedForever` の場合: 「位置情報の許可が永続的に拒否されています。設定アプリから許可してください」というダイアログを表示
5. `granted` の場合: `geolocator.getCurrentPosition()` を呼び出して緯度・経度を取得

**エラーハンドリング:**

- `LocationServiceDisabledException`: 「位置情報サービス（GPS）をオンにしてください」というダイアログを表示
- `PermissionDeniedException`: 「位置情報の許可が必要です」というトーストを表示

### 9.2 距離計算ロジック (Flutter)

基本設計書 に基づき、`lib/core/utils/distance_calculator.dart` に Haversine formula を実装する。

```dart
import 'dart:math';

class DistanceCalculator {
  /// 2地点間の距離を計算(Haversine formula)
  ///
  /// @param lat1 地点1の緯度
  /// @param lon1 地点1の経度
  /// @param lat2 地点2の緯度
  /// @param lon2 地点2の経度
  /// @return 距離(メートル)
  static double calculate(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    const double earthRadius = 6371000; // 地球の半径(メートル)

    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    double radLat1 = _toRadians(lat1);
    double radLat2 = _toRadians(lat2);

    double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(radLat1) * cos(radLat2) * sin(dLon / 2) * sin(dLon / 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    double distance = earthRadius * c;

    return distance;
  }

  /// 度をラジアンに変換
  static double _toRadians(double degrees) {
    return degrees * pi / 180;
  }

  /// 指定された距離(閾値)以内かどうかを判定
  static bool isWithinRange(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
    double thresholdMeters,
  ) {
    double distance = calculate(lat1, lon1, lat2, lon2);
    return distance <= thresholdMeters;
  }
}
```

### 9.3 チェックインフロー (確定)

基本設計書 に基づき、以下の処理フローを確定する。

1. **ユーザーがチェックインボタンをタップ** (SCR-USR-005)
2. **位置情報を取得** (Flutter: geolocator)
3. **APIリクエスト送信** `POST /api/v1/games/{gameId}/checkin` (latitude, longitude)
4. **サーバー側検証** (Laravel):
   - a. 試合が存在するか (E-404-02)
   - b. ユーザーがこの試合に参加登録済みか (E-400-08)
   - c. チェックイン可能時間内か（試合開始2時間前～試合終了時刻） (E-400-09)
   - d. 既にチェックイン済みでないか (E-409-04)
   - e. 試合会場からの距離が許容範囲内 (acceptable_radius) か (E-400-10)
5. **成功時: participations テーブルの status を「チェックイン済」に更新**
6. **成功レスポンス (200 OK) を返却**
7. **クライアント側: 成功トーストを表示し、画面を更新**

### 9.4 チェックイン実装 (Laravel)

#### app/Services/CheckinService.php

```php
<?php

namespace App\Services;

use App\Models\Game;
use App\Models\Participation;
use App\Repositories\GameRepository;
use App\Repositories\ParticipationRepository;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class CheckinService
{
    public function __construct(
        private GameRepository $gameRepository,
        private ParticipationRepository $participationRepository
    ) {}

    /**
     * チェックイン処理
     */
    public function checkin(string $userId, string $gameId, float $latitude, float $longitude): Participation
    {
        return DB::transaction(function () use ($userId, $gameId, $latitude, $longitude) {
            // 1. 試合取得
            $game = $this->gameRepository->findById($gameId);
            if (!$game) {
                throw new \Exception('試合が見つかりません', 404);
            }

            // 2. 参加登録確認
            $participation = $this->participationRepository->findByUserAndGame($userId, $gameId);
            if (!$participation) {
                throw new \Exception('この試合に参加登録していません', 400);
            }

            // 3. チェックイン時間確認
            $now = Carbon::now();
            $gameDateTime = Carbon::parse($game->game_date_time);
            $checkinStartTime = $gameDateTime->copy()->subHours(2);
            $checkinEndTime = $gameDateTime->copy()->addHours(3); // 試合時間3時間と仮定

            if ($now->lt($checkinStartTime) || $now->gt($checkinEndTime)) {
                throw new \Exception('チェックイン可能時間外です', 400);
            }

            // 4. 重複チェックイン確認
            if ($participation->status === 'チェックイン済') {
                throw new \Exception('既にチェックイン済みです', 409);
            }

            // 5. 距離確認
            $distance = $this->calculateDistance(
                $latitude,
                $longitude,
                $game->latitude,
                $game->longitude
            );

            if ($distance > $game->acceptable_radius) {
                throw new \Exception("会場から{$distance}メートル離れています", 400);
            }

            // 6. ステータス更新
            $participation->status = 'チェックイン済';
            $participation->save();

            return $participation;
        });
    }

    /**
     * Haversine formula による距離計算
     */
    private function calculateDistance(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $earthRadius = 6371000; // メートル

        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);

        $a = sin($dLat / 2) * sin($dLat / 2) +
            cos(deg2rad($lat1)) * cos(deg2rad($lat2)) *
            sin($dLon / 2) * sin($dLon / 2);

        $c = 2 * atan2(sqrt($a), sqrt(1 - $a));

        return $earthRadius * $c;
    }
}
```

### 9.5 コード生成AIへの共通コンテキスト (第9章)

**目的:**

第9章の定義に基づき、チェックイン機能の完全な実装を行う。

**指示:**

#### Flutter実装:

- `lib/core/utils/` に `distance_calculator.dart` を作成し、「9.2 距離計算ロジック」のコードを **完全に** 実装してください
- `lib/features/checkin/data/` に `CheckinRepository.dart` を作成し、位置情報取得（geolocator）とチェックインAPI呼び出しを実装してください
- SCR-USR-005（試合詳細画面）に「チェックイン」ボタンを追加し、タップ時に CheckinProvider を呼び出すよう実装してください

#### Laravel実装:

- `app/Services/` に `CheckinService.php` を作成し、「9.4 チェックイン実装」のコードを **完全に** 実装してください
- `app/Http/Controllers/` に `CheckinController.php` を作成し、`POST /api/v1/games/{gameId}/checkin` エンドポイントを実装してください
- 「9.3 チェックインフロー」に従い、すべての検証ロジックを実装してください

---

## 第10章 通知機能設計 (詳細定義)

基本設計書 第10章 の「詳細設計への共通コンテキスト」で指示されたタスク（通知テンプレート実装、Mailable実装）に基づき、プッシュ通知とメール通知の詳細仕様を以下の通り定義する。

### 10.1 プッシュ通知一覧 (確定)

基本設計書 に基づき、以下の通知を確定する。

| 通知ID | 通知名 | 配信タイミング | タイトル | 本文 |
|---|---|---|---|---|
| PUSH-001 | 試合登録完了通知 | 管理者が試合を登録した直後 | 試合を登録しました | {place_name} の試合が登録されました |
| PUSH-002 | 試合参加登録完了通知 | ユーザーが試合に参加登録した直後 | 参加登録が完了しました | {place_name} の試合への参加登録が完了しました |
| PUSH-003 | 試合開催前日リマインダー | バッチ処理（毎日深夜） | 明日の試合のお知らせ | {place_name} の試合が明日開催されます |

### 10.2 メール通知一覧 (確定)

基本設計書 に基づき、以下の通知を確定する。

| メールID | メール名 | 配信タイミング | 件名 | 本文概要 |
|---|---|---|---|---|
| MAIL-001 | アカウント登録完了メール | ユーザー登録完了直後 | アカウント登録完了 | 登録ありがとうございます。ニックネーム: {nickname} |
| MAIL-002 | パスワードリセット要求メール | パスワードリセット要求直後 | パスワードリセットのご案内 | 以下のリンクからパスワードを再設定してください: {reset_link} |
| MAIL-003 | パスワード変更完了メール | パスワード変更完了直後 | パスワード変更完了 | パスワードが変更されました |
| MAIL-004 | 試合参加登録完了メール | 試合参加登録完了直後 | 試合参加登録完了 | {place_name} の試合への参加登録が完了しました |
| MAIL-005 | 試合開催前日リマインダーメール | バッチ処理（毎日深夜） | 明日の試合のお知らせ | {place_name} の試合が明日開催されます |

### 10.3 Mailable実装 (Laravel)

#### 1. app/Mail/AccountRegistered.php

```php
<?php

namespace App\Mail;

use App\Models\User;
use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class AccountRegistered extends Mailable
{
    use Queueable, SerializesModels;

    public User $user;

    public function __construct(User $user)
    {
        $this->user = $user;
    }

    public function build()
    {
        return $this->subject('アカウント登録完了')
            ->view('emails.account_registered')
            ->with([
                'nickname' => $this->user->nickname,
            ]);
    }
}
```

#### 2. resources/views/emails/account_registered.blade.php

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>アカウント登録完了</title>
</head>
<body>
    <h1>{{ config('app.name') }} へようこそ！</h1>
    <p>{{ $nickname }} さん、アカウント登録が完了しました。</p>
    <p>草野球マッチングアプリをお楽しみください。</p>
</body>
</html>
```

### 10.4 FCM通知実装 (Laravel)

#### app/Services/NotificationService.php

```php
<?php

namespace App\Services;

use App\Repositories\DeviceTokenRepository;
use Kreait\Firebase\Messaging\CloudMessage;
use Kreait\Firebase\Messaging\Notification;
use Kreait\Firebase\Factory;

class NotificationService
{
    public function __construct(
        private DeviceTokenRepository $deviceTokenRepository
    ) {}

    /**
     * プッシュ通知を送信
     */
    public function sendPushNotification(string $userId, string $title, string $body): void
    {
        // FCMトークン取得
        $tokens = $this->deviceTokenRepository->findByUserId($userId);

        if (empty($tokens)) {
            return; // トークンがない場合は何もしない
        }

        // Firebase Messaging インスタンス作成
        $factory = (new Factory)->withServiceAccount(config('firebase.credentials'));
        $messaging = $factory->createMessaging();

        // 通知データ作成
        $notification = Notification::create($title, $body);

        // 各トークンに送信
        foreach ($tokens as $token) {
            try {
                $message = CloudMessage::withTarget('token', $token->fcm_token)
                    ->withNotification($notification);

                $messaging->send($message);
            } catch (\Exception $e) {
                // Unregistered トークンは削除
                if (str_contains($e->getMessage(), 'Unregistered')) {
                    $this->deviceTokenRepository->delete($token->device_token_id);
                }
            }
        }
    }
}
```

### 10.5 コード生成AIへの共通コンテキスト (第10章)

**目的:**

第10章の定義に基づき、プッシュ通知とメール通知の完全な実装を行う。

**指示:**

#### Mailable実装 (Laravel):

- `app/Mail/` に、「10.2 メール通知一覧」の全メールクラス（AccountRegistered.php, PasswordResetRequest.php など）を作成してください
- `resources/views/emails/` に、対応する Blade テンプレートを **すべて** 作成してください

#### FCM実装 (Laravel):

- `app/Services/` に `NotificationService.php` を作成し、「10.4 FCM通知実装」のコードを **完全に** 実装してください
- 各Service（AuthService, GameService など）から、適切なタイミングで NotificationService を呼び出してください

---

## 第11章 バッチ処理設計 (詳細定義)

基本設計書 第11章 の「詳細設計への共通コンテキスト」で指示されたタスク（Commandクラス実装、Kernel設定）に基づき、バッチ処理の詳細仕様を以下の通り定義する。

### 11.1 バッチ処理一覧 (確定)

基本設計書 に基づき、以下のバッチ処理を確定する。

| バッチID | バッチ名 | 実行タイミング | 処理内容 |
|---|---|---|---|
| BATCH-001 | 試合ステータス自動更新 | 毎時0分 | 試合開始1時間後に、ステータスが「募集中」「満員」の試合を「開催済み」に更新 |
| BATCH-002 | 試合開催前日リマインダー | 毎日 深夜2時 | 翌日開催予定の試合の参加者全員に、PUSH-003とMAIL-005を送信 |
| BATCH-003 | 古いトークンのクリーンアップ | 毎日 深夜3時 | 24時間以上前に作成されたトークン（password_reset_tokens等）を削除 |

### 11.2 Command実装 (Laravel)

#### app/Console/Commands/UpdateGameStatus.php

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Repositories\GameRepository;
use Carbon\Carbon;

class UpdateGameStatus extends Command
{
    protected $signature = 'game:update-status';
    protected $description = '試合ステータスを自動更新';

    public function __construct(
        private GameRepository $gameRepository
    ) {
        parent::__construct();
    }

    public function handle()
    {
        $oneHourAgo = Carbon::now()->subHour();

        // 開始1時間後の試合を「開催済み」に更新
        $count = $this->gameRepository->updateStatusToCompleted($oneHourAgo);

        $this->info("試合ステータス更新完了: {$count}件");
    }
}
```

### 11.3 Kernel設定 (Laravel)

#### app/Console/Kernel.php

```php
<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    protected function schedule(Schedule $schedule)
    {
        // BATCH-001: 試合ステータス自動更新（毎時0分）
        $schedule->command('game:update-status')
            ->hourly()
            ->withoutOverlapping()
            ->onOneServer();

        // BATCH-002: 試合開催前日リマインダー（毎日深夜2時）
        $schedule->command('game:send-reminder')
            ->dailyAt('02:00')
            ->withoutOverlapping()
            ->onOneServer();

        // BATCH-003: 古いトークンのクリーンアップ（毎日深夜3時）
        $schedule->command('token:cleanup')
            ->dailyAt('03:00')
            ->withoutOverlapping()
            ->onOneServer();
    }
}
```

### 11.4 コード生成AIへの共通コンテキスト (第11章)

**目的:**

第11章の定義に基づき、全バッチ処理を実装する。

**指示:**

- `app/Console/Commands/` に、「11.1 バッチ処理一覧」の全Commandクラスを作成してください
- `app/Console/Kernel.php` に、「11.3 Kernel設定」のスケジュール定義を **完全に** 実装してください
- 各Commandは、対応するRepository やServiceを呼び出してロジックを実行してください
