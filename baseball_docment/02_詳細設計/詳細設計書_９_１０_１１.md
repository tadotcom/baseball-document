詳細設計書：草野球マッチングアプリ第9章 位置情報・チェックイン機能設計 (詳細定義)基本設計書 第9章 の「詳細設計への共通コンテキスト」で指示されたタスク（Flutter実装、Laravel実装）に基づき、F-USR-008（チェックイン機能） の詳細仕様を以下の通り定義する。9.1. 位置情報取得方式 (Flutter)採用パッケージ: geolocator要求精度: LocationAccuracy.high （高精度GPS）権限要求フロー:ユーザーが SCR-USR-005（試合詳細） で「チェックイン」ボタンをタップ。CheckinRepository (または Provider) が geolocator.checkPermission() を呼び出す。denied の場合: geolocator.requestPermission() を呼び出し、OSの許可ダイアログを表示。deniedForever の場合: 「位置情報の許可が永続的に拒否されています。設定アプリから許可してください」というダイアログを表示。granted の場合: geolocator.getCurrentPosition() を呼び出して緯度・経度を取得。エラーハンドリング:LocationServiceDisabledException: 「位置情報サービス（GPS）をオンにしてください」というダイアログを表示。PermissionDeniedException: 「位置情報の許可が必要です」というトーストを表示。9.2. 距離計算ロジック (Flutter)基本設計書 に基づき、lib/core/utils/distance_calculator.dart に Haversine formula を実装する。Dartimport 'dart:math';

class DistanceCalculator {
  /// 2地点間の距離を計算(Haversine formula)
  ///
  /// @param lat1 地点1の緯度
  /// @param lon1 地点1の経度
  /// @param lat2 地点2の緯度
  /// @param lon2 地点2の経度
  /// @return 距離(メートル)
  static double calculate(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    const double earthRadius = 6371000; // 地球の半径(メートル)

    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    double radLat1 = _toRadians(lat1);
    double radLat2 = _toRadians(lat2);

    double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(radLat1) * cos(radLat2) * sin(dLon / 2) * sin(dLon / 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    double distance = earthRadius * c;

    return distance;
  }

  /// 度をラジアンに変換
  ///
  static double _toRadians(double degrees) {
    return degrees * pi / 180;
  }

  /// 指定された距離(閾値)以内かどうかを判定
  ///
  static bool isWithinRange(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
    double threshold, // 閾値(メートル)
  ) {
    double distance = calculate(lat1, lon1, lat2, lon2);
    return distance <= threshold;
  }
}
9.3. チェックイン判定フロー (Laravel)基本設計書 のフローに基づき、CheckinService (Laravel) のロジックを確定する。コントローラー: POST /api/v1/games/{gameId}/checkin を CheckinController@store で受ける。CheckinRequest（latitude, longitude のバリデーション）を使用。サービス: CheckinService->executeCheckin(User $user, string $gameId, float $latitude, float $longitude) を呼び出す。【サービス側バリデーション】a.  ParticipationRepository で参加情報を取得。* NG (未参加): E-400-08 で HTTP 400。b.  参加ステータスを確認。* NG (チェックイン済): E-409-04 で HTTP 409。c.  GameRepository で試合情報を取得。* NG (試合なし): E-404-02 で HTTP 404。d.  時間帯制御 (9.4参照): 現在時刻と game.game_date_time を比較。* NG (時間外): E-400-09 で HTTP 400。e.  距離計算: DistanceCalculator (PHP版) を呼び出し、リクエストの (lat, lon) と game.(latitude, longitude) の距離を計算。f.  計算結果を game.acceptable_radius と比較。* NG (範囲外): E-400-10 で HTTP 400。【DB更新処理】a.  トランザクション開始。b.  ParticipationRepository で participations.status を 'チェックイン済' にUPDATE。c.  トランザクションコミット。【通知】a.  PUSH-006（チェックイン完了）を Notification::queue で送信。レスポンス: HTTP 200 (成功) を返す。9.4. 時間帯制御 (Laravel)定義: エラーメッセージ定義書.csv に基づき、試合開始2時間前 ? 試合終了時刻 とする。実装: CheckinService (Laravel) 内で以下のロジックを実装する。game.game_date_time を取得。checkin_start_time = game_date_time - 2 hourscheckin_end_time = game_date_time + 3 hours （※試合の標準時間を3時間と仮定。games テーブルに終了時刻カラムがないため）NOW() が checkin_start_time と checkin_end_time の間にあるか判定する。9.5. コード生成AIへの共通コンテキスト (第9章)目的:第9章の定義に基づき、Flutter側の位置情報取得ロジックと、Laravel側のチェックインAPIロジックを実装する。指示:Flutter実装 (Util):lib/core/utils/ に distance_calculator.dart を作成し、「9.2. 距離計算ロジック」の Dart コードを 完全に 実装してください。Flutter実装 (Repository/Provider):CheckinRepository または checkinProvider に、チェックイン実行メソッド（executeCheckin など）を実装してください。メソッド内で、「9.1. 位置情報取得方式」に基づき geolocator を使用した権限要求と位置情報取得のフローを実装してください。位置情報取得後、POST /api/v1/games/{id}/checkin API に latitude と longitude を送信する処理を実装してください。E-400-09 (時間外), E-400-10 (距離エラー) などのAPIエラーをキャッチし、SnackBar や Dialog でユーザーにフィードバックしてください。Laravel実装 (Util):app/Utils/ に DistanceCalculator.php を作成し、「9.2.」の Haversine formula ロジックをPHPで実装してください。Laravel実装 (Service):app/Services/CheckinService.php を作成してください。executeCheckin メソッドに、「9.3. チェックイン判定フロー」のロジック（ステップ3a?3f）と、「9.4. 時間帯制御」のロジックを すべて 実装してください。バリデーションNG時は、abort(400, 'E-400-08') のように、指定されたエラーコード で処理を中断してください。DB更新処理（ステップ4）は DB::transaction() でラップしてください。通知（ステップ5）はトランザクションコミット 後 に Notification::queue() で実行してください。第10章 通知・メール設計 (詳細定義)基本設計書 第10章 の「詳細設計への共通コンテキスト」で指示されたタスク（Mailable, Notificationクラスの実装）に基づき、全テンプレートと実装クラスを以下の通り定義する。10.1. 通知種別一覧 (確定)プッシュ通知: 7種類 (PUSH-001 ? PUSH-007)メール: 7種類 (MAIL-001 ? MAIL-007)10.2. プッシュ通知テンプレート (確定)基本設計書 に基づき、7種類の通知テンプレートを確定する。通知IDタイトル本文トリガー優先度対象ユーザーPUSH-001試合登録完了「{place_name}」の試合を登録しました。F-ADM-006 (試合登録時)通常登録した管理者PUSH-002参加登録完了「{place_name}」への参加登録が完了しました。F-USR-006 (試合参加登録時)通常参加したユーザーPUSH-003試合リマインダーまもなく試合開始です。「{place_name}」 ( {game_date_time} )試合開始1時間前 (バッチ処理)高該当試合の全参加者PUSH-004試合中止のお知らせ「{place_name}」 ( {game_date_time} ) の試合は中止になりました。管理者が試合ステータスを「中止」に変更時高該当試合の全参加者PUSH-005試合満員のお知らせ「{place_name}」は満員になりました。試合ステータスが「満員」に変更時通常該当試合の全参加者PUSH-006チェックイン完了「{place_name}」へのチェックインが完了しました。F-USR-008 (チェックイン時)通常チェックインしたユーザーPUSH-007運営からのお知らせ{title}F-ADM-009 (一括通知配信時)高管理者が指定した対象者10.3. メールテンプレート (確定)基本設計書 に基づき、7種類のメールテンプレート（HTML形式）を確定する。MAIL-001: アカウント登録完了件名: 【草野球マッチング】アカウント登録完了トリガー: F-USR-001 (アカウント登録時)本文 (HTML):HTML<h2>アカウント登録完了</h2>
<p>{nickname}様</p>
<p>草野球マッチングアプリへのご登録ありがとうございます。</p>
MAIL-002: パスワードリセット要求件名: 【草野球マッチング】パスワードリセットのご案内トリガー: F-USR-004 (パスワードリセット要求時)本文 (HTML):HTML<h2>パスワードリセットのご案内</h2>
<p>{nickname}様</p>
<p>以下のリンクをクリックして、パスワードの再設定を完了してください。<br>
   このリンクの有効期限は60分です。</p>
<p><a href="{reset_url}">パスワードをリセットする</a></p>
MAIL-003: パスワードリセット完了件名: 【草野球マッチング】パスワードリセット完了のお知らせトリガー: F-USR-004 (パスワードリセット実行時)MAIL-004: 試合参加登録完了件名: 【草野球マッチング】試合参加登録完了のお知らせトリガー: F-USR-006 (試合参加登録時)本文 (HTML):HTML<h2>試合参加登録完了</h2>
<p>{nickname}様</p>
<p>以下の試合への参加登録が完了しました。</p>
<p>
  <strong>試合:</strong> {place_name}<br>
  <strong>日時:</strong> {game_date_time}<br>
  <strong>住所:</strong> {address}<br>
</p>
MAIL-005: 試合中止のお知らせ件名: 【草野球マッチング】試合中止のお知らせトリガー: 管理者が試合ステータスを「中止」に変更時MAIL-006: 強制退会通知件名: 【草野球マッチング】アカウント停止のお知らせトリガー: F-ADM-003 (ユーザー強制退会時)MAIL-007: 管理者向け一括配信件名: 【草野球マッチング】{title}トリガー: F-ADM-010 (メール配信時)本文 (HTML): {body} (管理者が入力したHTML本文)10.4. コード生成AIへの共通コンテキスト (第10章)目的:第10章の定義に基づき、Laravelの Mailable クラスと Notification クラスを実装する。指示:Mailableクラスの実装 (Laravel):app/Mail/ 配下に、「10.3.」で定義された7種類のメールに対応する Mailable クラス（例: AccountRegistered.php, PasswordResetLink.php, GameParticipantRegistered.php など）を すべて 作成してください。各クラスの __construct で、テンプレート（{nickname} や {game_date_time} など）に必要なデータを（User や Game オブジェクトとして）受け取れるようにしてください。build メソッド（または content メソッド）で、resources/views/emails/ 配下の対応する Blade テンプレート（例: emails.account_registered）と件名（subject()）を指定してください。Notificationクラスの実装 (Laravel):app/Notifications/ 配下に、「10.2.」で定義された7種類のプッシュ通知に対応する Notification クラス（例: GameReminder.php, GameCancelled.php, CheckinCompleted.php など）を すべて 作成してください。via メソッドで ['fcm']（または DatabaseChannel）を返すようにしてください。toFcm メソッドを実装し、FCMに送信するペイロード（title, body）を「10.2.」のテンプレート通りに定義してください。Bladeテンプレートの実装 (Laravel):resources/views/emails/ 配下に、「10.3.」の Mailable クラスに対応する Blade ファイル（例: account_registered.blade.php）を すべて 作成し、「10.3.」のHTMLテンプレートを実装してください。Service層への組み込み (Laravel):第3章、第9章、第11章で定義したトリガー（例: AuthService@register, GameService@addParticipant, CheckinService@executeCheckin, SendGameReminder バッチ）の トランザクションコミット後 に、対応する Mailable や Notification を Mail::queue() または User->notify() で非同期送信（キューイング）する処理を実装してください。例外: MAIL-002 (パスワードリセット要求) のみ、Mail::sendNow() で同期送信してください。第11章 バッチ処理設計 (詳細定義)基本設計書 第11章 の「詳細設計への共通コンテキスト」で指示されたタスク（コマンドクラスの実装、Kernelクラスの編集、Pruning設定）に基づき、バッチ処理を以下の通り定義する。11.1. バッチ処理の実装コード1. 試合ステータス自動更新バッチapp/Console/Commands/UpdateGameStatus.php基本設計書 に記載のPHPコードをそのまま実装する。PHP<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Game;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB; // DBファサードの追加

class UpdateGameStatus extends Command
{
    protected $signature = 'games:update-status';
    protected $description = '試合ステータスを自動更新(募集中/満員→開催済み)';

    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 固定ルール: 試合開始1時間後を「開催済み」とする
        $thresholdTime = Carbon::now()->subHour(1);

        $gamesToUpdate = Game::where('game_date_time', '<=', $thresholdTime)
                             ->whereIn('status', ['募集中', '満員'])
                             ->get();

        if ($gamesToUpdate->isEmpty()) {
            Log::info('[BATCH END] 更新対象の試合はありませんでした。');
            return 0;
        }

        $count = 0;
        foreach ($gamesToUpdate as $game) {
            // 固定ルール: 排他制御のためDBロック
            try {
                DB::transaction(function () use ($game) {
                    $lockedGame = Game::where('game_id', $game->game_id)->lockForUpdate()->first();
                    
                    if ($lockedGame && in_array($lockedGame->status, ['募集中', '満員'])) {
                        $lockedGame->status = '開催済み';
                        $lockedGame->save();
                    }
                });
                $count++;
            } catch (\Exception $e) {
                Log::error('[BATCH ERROR] 試合ステータス更新失敗 (GameID: ' . $game->game_id . ')', ['exception' => $e->getMessage()]);
            }
        }

        Log::info('[BATCH END] ' . $count . '件の試合ステータスを「開催済み」に更新しました。');
        return 0;
    }
}
2. プッシュ通知配信バッチ (試合リマインダー)app/Console/Commands/SendGameReminder.php基本設計書 に記載のPHPコードをそのまま実装する。PHP<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Game;
use App\Notifications\GameReminder; // (第10章で定義)
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class SendGameReminder extends Command
{
    protected $signature = 'notifications:send-reminder';
    protected $description = '試合開始1時間前の参加者にリマインダー通知を送信';

    public function handle()
    {
        Log::info('[BATCH START] ' . $this->description);

        // 1時間後?1時間10分後に開始される試合を対象 (cronの実行間隔を考慮)
        $startTime = Carbon::now()->addHour();
        $endTime = Carbon::now()->addHour()->addMinutes(10);

        $games = Game::whereIn('status', ['募集中', '満員'])
                     ->whereBetween('game_date_time', [$startTime, $endTime])
                     ->with('participants.user') // N+1問題回避
                     ->get();

        if ($games->isEmpty()) {
            Log::info('[BATCH END] 通知対象の試合はありませんでした。');
            return 0;
        }

        $totalUsers = 0;
        foreach ($games as $game) {
            foreach ($game->participants as $participation) {
                $user = $participation->user;
                // ユーザーが存在し、(論理削除されておらず)、通知先トークンがある場合
                if ($user && $user->deviceTokens()->exists()) {
                    try {
                        // PUSH-003
                        $user->notify(new GameReminder($game));
                        $totalUsers++;
                    } catch (\Exception $e) {
                        Log::error('[BATCH ERROR] リマインダー通知送信失敗 (UserID: ' . $user->user_id . ')', ['exception' => $e->getMessage()]);
                    }
                }
            }
        }

        Log::info('[BATCH END] ' . $totalUsers . '人のユーザーにリマインダー通知を送信しました。');
        return 0;
    }
}
3. 論理削除データ物理削除 (Pruning)非機能要件（退会後60日後物理削除）に基づき、app/Models/User.php に設定を追加する。PHP// app/Models/User.php に以下を追加

use Illuminate\Database\Eloquent\Prunable; // 1. トレイトをインポート

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable, SoftDeletes, Prunable; // 2. トレイトを使用

    /**
     * Get the prunable model query.
     *
     */
    public function prunable(): \Illuminate\Database\Eloquent\Builder
    {
        // 60日以上前に論理削除 (deleted_at) されたユーザーを対象
        return static::where('deleted_at', '<=', now()->subDays(60));
    }
}
11.2. cronスケジュール設定1. Laravelスケジューラーの設定app/Console/Kernel.php に、バッチ処理のスケジュールを定義する。PHP<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    protected function schedule(Schedule $schedule): void
    {
        // 試合ステータス自動更新バッチ (毎時0分実行)
        $schedule->command('games:update-status')
             ->cron('0 * * * *') // 毎時0分
             ->withoutOverlapping() // 重複実行防止
             ->runInBackground();

        // 試合リマインダー通知バッチ (毎10分実行)
        $schedule->command('notifications:send-reminder')
             ->cron('*/10 * * * *') // 毎10分
             ->withoutOverlapping()
             ->runInBackground();
        
        // 論理削除データ物理削除バッチ (毎日深夜3時実行)
        $schedule->command('model:prune', [
            '--model' => [\App\Models\User::class],
        ])->dailyAt('03:00');
    }

    protected function commands(): void
    {
        $this->load(__DIR__.'/Commands');
        require base_path('routes/console.php');
    }
}
2. システムcronの設定サーバー (Xserver VPS) のcrontabに、Laravelスケジューラーを毎分実行するための設定を追加する。Bash# sudo crontab -e
# 以下を追加:
* * * * * cd /var/www/grass-baseball-matching && php artisan schedule:run >> /dev/null 2>&1
11.3. コード生成AIへの共通コンテキスト (第11章)目的:第11章の定義に基づき、サーバーサイドの全バッチ処理（Artisanコマンド）とスケジューラー設定を実装する。指示:コマンドクラスの実装 (Laravel):app/Console/Commands/ 配下に、「11.1.1. UpdateGameStatus.php」と「11.1.2. SendGameReminder.php」を、記載されているPHPコードの通りに 完全に 実装してください。use 文（DB, Log, Carbon など）の不足がないか確認してください。Pruningの実装 (Laravel):app/Models/User.php を開き、「11.1.3. 論理削除データ物理削除」の指示通り、Prunable トレイトの use 文と prunable() メソッドを 両方 追加してください。スケジューラー設定 (Laravel):app/Console/Kernel.php を開き、「11.2.1. Laravelスケジューラーの設定」の schedule メソッドの内容（games:update-status, notifications:send-reminder, model:prune の3つのコマンド）を 完全に 実装してください。デプロイ手順への反映:「11.2.2. システムcronの設定」に記載されている crontab の設定行を、第16章（デプロイ設計） で作成する「環境構築手順書」または「デプロイ手順書」に 必ず 含めてください。