# 詳細設計書：草野球マッチングアプリ

## 第7章 セキュリティ設計 (詳細定義)

基本設計書 第7章 の「詳細設計への共通コンテキスト」で指示されたタスク（ミドルウェアの実装、クライアント側実装、レートリミット実装）に基づき、セキュリティ対策を以下の通り定義する。

### 7.1 認証・認可フロー (確定)

基本設計書 に基づき、以下のフローを確定する。

**認証:** Laravel Sanctum (PAT, 24時間有効, リフレッシュトークンなし)

**クライアント側:**

- トークンは `flutter_secure_storage` に保存
- HTTP 401 受信時はトークンを削除し、SCR-USR-001 (ログイン画面) に強制遷移

**認可:**

- `/api/v1/admin/*` へのアクセスは、`auth:sanctum` ミドルウェアに加え、`AdminMiddleware` で管理者権限をチェック

### 7.2 Laravel ミドルウェア実装

#### 1. app/Http/Middleware/AdminMiddleware.php

管理者権限（例: admin@yourdomain.com）をチェックするミドルウェア。

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Illuminate\Support\Facades\Auth;

class AdminMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        // sanctum で認証済みか確認
        if (!Auth::check()) {
            return response()->json([
                'error' => [
                    'code' => 'E-401-01',
                    'message' => '認証に失敗しました',
                    'details' => []
                ],
                'meta' => ['timestamp' => now()->toIso8601String()]
            ], 401);
        }

        // 管理者かどうかの判定 (例: 初期管理者のEmailで判定)
        // ※ 本来は users.role カラムなどで行うのが望ましい
        if (Auth::user()->email !== 'admin@yourdomain.com') {
            return response()->json([
                'error' => [
                    'code' => 'E-403-01',
                    'message' => '管理者権限が必要です',
                    'details' => []
                ],
                'meta' => ['timestamp' => now()->toIso8601String()]
            ], 403);
        }

        return $next($request);
    }
}
```

#### 2. app/Http/Kernel.php (ミドルウェアの登録)

```php
<?php

namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel
{
    // ...

    /**
     * The application's route middleware aliases.
     *
     * @var array
     */
    protected $middlewareAliases = [
        // ...
        'admin' => \App\Http\Middleware\AdminMiddleware::class, // 'admin' エイリアスを登録
    ];
}
```

### 7.3 レートリミット実装

固定ルール に基づき、`app/Providers/RouteServiceProvider.php` でレートリミットを設定する。

```php
<?php

namespace App\Providers;

use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\Facades\Route;

class RouteServiceProvider extends ServiceProvider
{
    // ...

    /**
     * Configure the rate limiters for the application.
     */
    protected function configureRateLimiting(): void
    {
        // 認証不要API (IPベース)
        RateLimiter::for('api', function (Request $request) {
            // ログイン試行は別途制限
            if ($request->is('api/v1/auth/login')) {
                return Limit::perMinute(5)->by($request->ip()); // ログイン: 5回/分/IP
            }

            // 認証不要のその他API
            return Limit::perMinute(60)->by($request->ip()); // 60回/分/IP
        });

        // 認証必須API (ユーザーIDベース)
        RateLimiter::for('api_authenticated', function (Request $request) {
            return $request->user()
                ? Limit::perMinute(120)->by($request->user()->id) // 120回/分/ユーザー
                : Limit::perMinute(60)->by($request->ip()); // フォールバック (基本は通らない)
        });
    }

    // (routes/api.php の 'middleware' => 'throttle:...' に適用)
}
```

### 7.4 OWASP Top 10対策 (確定)

基本設計書 の「7.7 OWASP Top 10対策」の表を、本詳細設計の確定仕様とする。

| 脆弱性 | 対策内容 (確定) |
|---|---|
| A01: アクセス制御の不備 | `auth:sanctum` および `AdminMiddleware` での認可徹底 |
| A02: 暗号化の失敗 | TLS 1.2以上 (HTTPS)。Bcrypt ハッシュ。`flutter_secure_storage` |
| A03: インジェクション | Eloquent ORM (パラメータバインディング) のみ使用。生SQL禁止 |
| A04: 安全でない設計 | 7.3 のレートリミットを実装 |
| A05: セキュリティ設定の不備 | 本番環境 `APP_DEBUG=false`。Nginxでバージョン情報非表示 |
| A06: 脆弱で時代遅れのコンポーネント | `composer audit` のCI/CDへの組み込み |
| A07: 識別と認証の失敗 | 24時間トークン期限、リフレッシュなし、ログアウト時トークン無効化 |
| A08: ソフトウェアとデータの完全性の不備 | 信頼できないソースからの `unserialize()` 禁止 |
| A09: セキュリティログと監視の不備 | ログイン失敗、パスワードリセット等のイベントをログ記録（第12章） |
| A10: サーバーサイドリクエストフォージェリ (SSRF) | 外部URLへのリクエスト機能はなし。実装時は許可リスト検証を必須とする |

### 7.5 コード生成AIへの共通コンテキスト (第7章)

**目的:**

第7章の定義に基づき、セキュリティ関連のミドルウェア、クライアント側トークン管理、レートリミット設定を実装する。

**指示:**

#### ミドルウェアの実装 (Laravel):

- `app/Http/Middleware/` に「7.2 AdminMiddleware.php」を **完全に** 実装してください
- `app/Http/Kernel.php` の `$middlewareAliases` に `'admin'` エイリアスを登録してください

#### レートリミットの実装 (Laravel):

- `app/Providers/RouteServiceProvider.php` の `configureRateLimiting` メソッドに、「7.3 レートリミット実装」のコードを **完全に** 実装してください
- `routes/api.php` のルート定義において、認証不要グループには `middleware('throttle:api')` を、認証必須グループには `middleware('throttle:api_authenticated')` を適用してください（第5章のタスク）

#### トークン管理の実装 (Flutter):

- `lib/core/services/` に `TokenStorageService.dart` を作成してください
- `flutter_secure_storage` を使用し、`saveToken(String token)`, `Future<String?> getToken()`, `Future<void> deleteToken()` の3つのメソッドを実装してください
- `authProvider` の login / register 成功時に `saveToken` を、logout 時に `deleteToken` を呼び出すように実装してください

#### HTTP 401ハンドリング (Flutter):

- APIクライアント（Dioなど）に Interceptor を追加してください
- `onError` でレスポンスのステータスコードが 401 だった場合、グローバルに `TokenStorageService.deleteToken()` を呼び出し、`authProvider` の状態を更新し、Navigator を使って SCR-USR-001 (ログイン画面) に強制遷移させるロジックを実装してください

---

## 第8章 外部連携設計 (詳細定義)

基本設計書 第8章 の「詳細設計への共通コンテキスト」で指示されたタスク（FCM実装、SMTP実装、Google Maps実装）に基づき、外部連携仕様を以下の通り定義する。

### 8.1 Firebase Cloud Messaging (FCM) 連携

#### 1. 設定ファイル配置 (確定)

- iOS: `ios/Runner/GoogleService-Info.plist`
- Android: `android/app/google-services.json`

#### 2. 初期化コード (Flutter)

`lib/main.dart` に、基本設計書 のコードを実装する。

```dart
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// (MyApp などのインポート)
// (TokenStorageService, FcmService などのインポート)

// バックグラウンドメッセージハンドラー
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  print('バックグラウンドメッセージ受信: ${message.messageId}');
  // TODO: ローカル通知 (flutter_local_notifications) を表示
}

void main() async {
  // Flutter Engineの初期化
  WidgetsFlutterBinding.ensureInitialized();

  // Firebase初期化
  await Firebase.initializeApp();

  // バックグラウンドメッセージハンドラーの設定
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // フォアグラウンド通知の表示設定
  await FirebaseMessaging.instance.setForegroundNotificationPresentationOptions(
    alert: true,
    badge: true,
    sound: true,
  );

  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}
```

#### 3. デバイストークン登録処理 (Flutter)

ログイン完了時に呼び出す `FcmService` を定義する。

`lib/core/services/fcm_service.dart`

```dart
import 'dart:io' show Platform;
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// (APIクライアントや DeviceTokenRepository のインポート)

// Provider の定義
final fcmServiceProvider = Provider((ref) {
  return FcmService(ref);
});

class FcmService {
  final Ref ref;
  final FirebaseMessaging _fcm = FirebaseMessaging.instance;

  FcmService(this.ref);

  /// 通知許可の要求とトークン登録の初期化
  Future<void> initializeAndRegisterToken() async {
    // 1. 通知許可ダイアログの表示 (iOS / Android 13+)
    NotificationSettings settings = await _fcm.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      print('通知許可: 許可されました');

      // 2. FCMトークンの取得
      final String? token = await _fcm.getToken();

      if (token != null) {
        print('FCM Token: $token');

        // 3. サーバーへトークンを送信
        await _registerTokenToServer(token);
      }

      // 4. トークンが更新された場合のリスナー設定
      _fcm.onTokenRefresh.listen(_registerTokenToServer);
    } else {
      print('通知許可: 拒否されました');
    }
  }

  /// サーバーにFCMトークンを登録する
  Future<void> _registerTokenToServer(String token) async {
    try {
      final String deviceType = Platform.isIOS ? 'ios' : 'android';

      // 第2章で定義した Repository Provider を呼び出す
      // await ref.read(deviceTokenRepositoryProvider).registerToken(
      //   token: token,
      //   deviceType: deviceType,
      // );

      print('FCMトークンをサーバーに登録しました。');
    } catch (e) {
      print('FCMトークン登録失敗: $e');
      // 失敗してもエラーとはしない（通知が届かないだけ）
    }
  }
}
```

#### 4. プッシュ通知送信フロー (Laravel)

F-ADM-009（プッシュ通知配信） のフローを確定する。

1. 管理者が `POST /api/v1/admin/notifications/push` を呼び出す
2. `NotificationService` (Laravel) が対象ユーザーの `device_tokens` をDBから取得
3. FCM Admin SDK (PHP) を使用し、対象トークンにメッセージ（第10章のテンプレート）を送信
4. FCM API から `Unregistered` エラーが返却されたトークンは、`device_tokens` テーブルから削除する

### 8.2 メール配信 (SMTP)

**連携方式:** Laravel の `Mail` ファサードを使用し、Xserver の SMTP サーバー経由で送信

**設定 (.env):**

```
MAIL_MAILER=smtp
MAIL_HOST=your-xserver-smtp-host.com
MAIL_PORT=587
MAIL_USERNAME=your-smtp-username
MAIL_PASSWORD=your-smtp-password
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS="support@yourdomain.com"
MAIL_FROM_NAME="${APP_NAME}"
```

**配信タイミングとリトライ:**

- **同期 (Mail::sendNow)**: パスワードリセット要求 (F-USR-004)
- **非同期 (Mail::queue)**: アカウント登録完了 (F-USR-001), 管理者メール配信 (F-ADM-010)
- **リトライ (非同期のみ)**: 3回 (5分, 15分, 30分間隔)。3回失敗時はログ (E-500-02) に記録

### 8.3 Google Maps連携

**連携方式:** ディープリンク (URLスキーム)

**Flutter実装:**

SCR-USR-005 (試合詳細) の住所タップ時に、`url_launcher` パッケージを使い以下の関数を呼び出す。

```dart
import 'package:url_launcher/url_launcher.dart';

Future<void> launchGoogleMaps(String address) async {
  final String query = Uri.encodeComponent(address);

  // iOSとAndroidで共通のWeb URLを使用し、OSに起動を委ねる
  final Uri url = Uri.parse('https://www.google.com/maps/search/?api=1&query=$query');

  // (古いディープリンク方式: 'comgooglemaps://?q=$query' or 'geo:0,0?q=$query')

  if (await canLaunchUrl(url)) {
    await launchUrl(url, mode: LaunchMode.externalApplication);
  } else {
    // エラー処理（例: トースト表示）
    print('地図アプリを起動できませんでした');
  }
}
```

### 8.4 コード生成AIへの共通コンテキスト (第8章)

**目的:**

第8章の定義に基づき、Firebase (FCM), SMTP, Google Maps と連携するためのコードを実装する。

**指示:**

#### FCM実装 (Flutter):

- `lib/main.dart` に「8.1.2 初期化コード」を **完全に** 実装してください（`Firebase.initializeApp()` を含む）
- `lib/core/services/` に `FcmService.dart` を作成し、「8.1.3 デバイストークン登録処理」のコードを **完全に** 実装してください
- `authProvider` がログイン（またはアプリ起動時のトークン検証）に成功したタイミングで、`ref.read(fcmServiceProvider).initializeAndRegisterToken()` を呼び出す処理を追加してください

#### FCM実装 (Laravel):

- `POST /api/v1/device-tokens` のAPI（Controller, Service, Repository）を実装してください（第5章のタスク）
- Serviceは、受け取った `token` と `device_type` を `device_tokens` テーブルに upsert（存在すれば更新、なければ挿入）するロジックを実装してください
- F-ADM-009（プッシュ通知配信）の `NotificationService` (第10章) に、「8.1.4 プッシュ通知送信フロー」に基づき、FCM Admin SDK (PHP) を使って通知を送信するロジックを実装してください

#### SMTP実装 (Laravel):

- `.env` ファイルに「8.2 設定」を反映させてください（MAIL_HOST などは実際の値に置き換える）
- 第10章で作成する Mailable クラス（AccountRegistered など）を、`AuthService` などから呼び出す際に、「8.2 配信タイミング」に従い `Mail::queue()`（非同期）または `Mail::sendNow()`（同期）を使い分けてください

#### Google Maps実装 (Flutter):

- SCR-USR-005 (試合詳細画面) の住所を表示する `ListTile` または `Text` Widget を `InkWell` でラップしてください
- `onTap` イベントで、「8.3 Google Maps連携」の `launchGoogleMaps(address)` 関数を呼び出すよう実装してください
